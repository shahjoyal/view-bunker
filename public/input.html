<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Blend Dashboard — Bunkers</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
   <style>
    :root{
      /* primary tunables - tweak these to change overall scaling */
      --bg:#F7F8FA; --card:#fff; --muted:#6b7280; --accent:#02008a;
      --sidebar-width:170px;
      --topbar-height:64px;

      /* bunker sizing (clamp will keep heights responsive) */
      --bunker-min-height:220px;
      --bunker-max-height:520px;
      --bunker-top-line-distance: 46px;
      --arrow-width: 3px;
      --bunker-arrow-height: 90px;
      --arrow-head-size: 12px;

      /* spacing */
      --app-gap:12px;
      --content-padding:12px;
    }

    /* --- Base layout: force app to exactly viewport height and remove page scroll --- */
    html, body {
      height:100%;
      margin:0;
      padding:0;
      width:100%;
      overflow-x:hidden;            /* no horizontal browser scroll */
      overflow-y:hidden;            /* remove vertical browser scroll */
      font-family:Inter, system-ui, Arial, sans-serif;
      background:var(--bg);
      color:#111;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    /* app fills viewport exactly; children must scale internally */
    .app {
      display:flex;
      height:100vh;                 /* lock to viewport */
      gap:var(--app-gap);
      box-sizing:border-box;
    }

    /* sidebar */
    .sidebar {
      width:var(--sidebar-width);
      background:#fff;
      border-right:1px solid rgba(0,0,0,0.04);
      padding:12px 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.03);
      display:flex;
      flex-direction:column;
      gap:6px;
      box-sizing:border-box;
      flex-shrink:0;
      min-width:120px;
    }
    .sidebar .title { font-weight:800; color:var(--accent); padding:8px 10px; font-size:13px; }
    .sidebar .item {
      display:block;
      padding:8px 10px;
      border-radius:8px;
      cursor:pointer;
      font-weight:700;
      color:#111;
      font-size:13px;
    }
    .sidebar .item:hover { background:rgba(2,0,138,0.05); }
    .sidebar .item.active { background:var(--accent); color:#fff; box-shadow:0 6px 18px rgba(2,0,138,0.12); }

    /* main area: reserve space for topbar and content; prevent page scroll */
    .main {
      flex:1;
      display:flex;
      flex-direction:column;
      box-sizing:border-box;
      padding:12px 18px;
      gap:12px;
      min-width:0;                  /* important to prevent horizontal overflow */
      height:100%;                  /* fill remaining height */
      overflow:hidden;              /* no page scrolling — content will adapt inside */
    }

    /* topbar fixed height */
    .topbar {
      height:var(--topbar-height);
      min-height:var(--topbar-height);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      margin-bottom:0;
      flex-shrink:0;
    }
    .topbar h1{ margin:0; font-size:16px; color:var(--accent); font-weight:800; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .controls{ display:flex; gap:8px; align-items:center; }
    .controls input{ padding:8px 10px; border-radius:8px; border:1px solid #e6e6e6; width:110px; font-size:14px; background:#fff; cursor:pointer; }

    /* layout card becomes a column flex so inner parts can shrink/flow */
    .layout-card{
      background:var(--card);
      border-radius:12px;
      padding:12px;
      box-shadow:0 10px 30px rgba(2,8,23,0.06);
      position:relative;
      overflow:visible;
      display:flex;
      flex-direction:column;
      gap:12px;
      height: calc(100% - var(--topbar-height) - 12px); /* fill remaining main area */
      box-sizing:border-box;
    }

    /* the main row is flexible and will wrap on small heights/widths */
    .layout-row{
      display:flex;
      gap:12px;
      align-items:flex-start;
      flex:1 1 auto;
      min-height:0; /* allow children to shrink */
      flex-wrap:wrap; /* wrap if width is constrained */
    }

    .diagram-column{
      flex:1 1 0;
      min-width:0;
      display:flex;
      flex-direction:column;
      gap:8px;
      min-height:0;
    }
    .stats-column{
      width:160px;
      flex-shrink:0;
      min-width:140px;
    }

    /* stats panel stays visible but will shrink its content */
    .stats-panel{
      width:100%;
      background:#02008a;
      color:#fff;
      padding:8px 10px;
      border-radius:8px;
      box-shadow:0 10px 22px rgba(2,8,23,0.10);
      display:flex;
      flex-direction:column;
      gap:6px;
      z-index:20;
      position:sticky;
      top: calc(var(--topbar-height) + 20px);
      font-size:13px;
    }
    .stat-row{ display:flex; justify-content:space-between; font-weight:700; }
    .stat-label{ opacity:0.95; font-weight:600; font-size:12px; color:rgba(255,255,255,0.95); }
    .stat-value{ font-weight:800; font-size:13px; }

    .diagram-inner { position:relative; padding:8px; min-height:0; display:flex; flex-direction:column; gap:8px; }

    .top-overlay { position: absolute; inset: 0 0 0 0; pointer-events: none; z-index: 90; }
    .top-line { position: absolute; top: var(--bunker-top-line-distance); left: 4%; right: 4%; height: 3px; background: #000; opacity:1; }

    .arrow { position: absolute; width: var(--arrow-width); background: #000; top: calc(var(--bunker-top-line-distance) + 4px); height: var(--bunker-arrow-height); transform-origin: top center; }
    .arrow::after { content: ''; position: absolute; left: calc(50% - 8px); top: 100%; width: 0; height: 0; border-left: 8px solid transparent; border-right: 8px solid transparent; border-top: var(--arrow-head-size) solid #000; }

    /* bunkers grid: allow wrapping so it never forces page size bigger than viewport */
    .bunkers-grid{
      display:flex;
      gap:18px;
      align-items:end;
      padding:18px;
      flex-wrap:wrap;          /* <-- important: wrap to new line if not enough width */
      box-sizing:border-box;
      justify-content:space-between;
      width:100%;
    }

    /* bunker heights will scale within clamp to prevent overflow */
    .bunker{
      position:relative;
      flex:1 1 14%;            /* allow shrink/grow; base width ~14% */
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:flex-end;
      min-width:120px;         /* prevents elements becoming too narrow */
      box-sizing:border-box;
      height: clamp(var(--bunker-min-height), 40vh, var(--bunker-max-height));
      max-height: calc(var(--bunker-max-height));
    }

    /* svg occupies available bunker height but is constrained */
    .bunker svg{ width:100%; height:100%; max-height:100%; display:block; object-fit:contain; }
    .bunker .label{ position:absolute; bottom:5px; left:50%; transform:translateX(-50%); background:rgba(255,255,255,0.98); padding:6px 10px; border-radius:8px; box-shadow:0 2px 10px rgba(0,0,0,0.06); font-weight:700; font-size:13px; white-space:nowrap; }

    /* single-bunker view reduced sizes to avoid overflow */
    .single-bunker-wrap { padding:12px; display:flex; justify-content:center; align-items:flex-start; }
    .single-bunker {
      width:100%;
      max-width:920px;
      height: clamp(240px, 66vh, 720px);
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:flex-end;
      position:relative;
    }
    .single-bunker svg{ width:60%; height:92%; max-height:640px; display:block; }
    .single-bunker .label{ position: absolute; bottom:-30px; left:50%; transform:translateX(-50%); background:rgba(255,255,255,0.98); padding:8px 12px; border-radius:10px; font-weight:800; font-size:16px; white-space:nowrap; }

    /* tooltip */
    .coal-tooltip {
      position: absolute;
      pointer-events: none;
      background: #fff;
      color: #111;
      border: 1px solid rgba(0,0,0,0.12);
      box-shadow: 0 6px 18px rgba(0,0,0,0.12);
      padding: 10px;
      border-radius: 8px;
      font-size: 13px;
      line-height:1.35;
      z-index: 2000;
      display: none;
      min-width: 160px;
    }

    /* ---------- Coal Flow boxes (UI only) ---------- */
    .coal-flow-wrap { margin-top:0; padding:0 0 8px; }
    .coal-flow-title { font-weight:800; margin:6px 18px 8px; color:var(--accent); font-size:14px; }
    .coal-flow-grid { display:flex; gap:12px; align-items:stretch; padding:0 18px; box-sizing:border-box; flex-wrap:wrap; }
    .coal-box {
      flex:1 1 14%;
      min-width:110px;
      height:56px;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      border-radius:10px;
      background:var(--card);
      box-shadow:0 8px 20px rgba(2,8,23,0.06);
      font-weight:800;
      font-size:13px;
      box-sizing:border-box;
    }
    .coal-box .value { font-size:15px; }
    .coal-box .label { font-size:12px; color:var(--muted); font-weight:700; margin-top:4px; }

    /* responsive: stack vertically on narrow screens and shrink heights */
    @media (max-width:1100px){
      .layout-row{ flex-direction:column; gap:10px; }
      .stats-column{ width:100%; order:2; }
      .sidebar{ display:none; } /* hide left sidebar on narrow screens to save space */
      .single-bunker svg{ width:80%; }
      .coal-flow-grid { gap:8px; padding:0 8px; }
      .coal-box { width:100%; flex-basis:auto; }
      .bunkers-grid { padding:8px; gap:10px; }
      .bunker { height: clamp(180px, 30vh, 380px); }
    }

    /* very short viewport (example: small laptop height) — make elements more compact */
    @media (max-height:720px){
      :root{
        --bunker-top-line-distance: 36px;
      }
      .bunker { height: clamp(160px, 36vh, 420px); }
      .coal-box { height:48px; }
      .topbar { height:56px; }
      .layout-card { padding:10px; }
    }

    /* ensure no element produces unintended browser scrollbar */
    * { box-sizing:border-box; }
  </style>
</head>
<body>
  <div class="app">

    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar">
      <div class="title">Views</div>
      <div class="item active" data-mode="overview" id="tab-overview">Overview</div>
      <div class="item" data-mode="bunker" data-index="0">Bunker 1</div>
      <div class="item" data-mode="bunker" data-index="1">Bunker 2</div>
      <div class="item" data-mode="bunker" data-index="2">Bunker 3</div>
      <div class="item" data-mode="bunker" data-index="3">Bunker 4</div>
      <div class="item" data-mode="bunker" data-index="4">Bunker 5</div>
      <div class="item" data-mode="bunker" data-index="5">Bunker 6</div>
    </aside>

    <!-- Main -->
    <main class="main">
      <div class="topbar">
        <h1>Blend Dashboard — Bunkers</h1>
        <div class="controls">
          <input id="refreshBtn" type="button" value="Refresh" />
        </div>
      </div>

      <div class="layout-card">
        <!-- main row -->
        <div class="layout-row">
          <div class="diagram-column">
            <div class="diagram-inner" id="diagramInner">
              <div class="top-overlay" aria-hidden="true" id="topOverlay">
                <div class="top-line" id="topLine"></div>
                <div class="arrow" style="left:8.3333%;"></div>
                <div class="arrow" style="left:25%;"></div>
                <div class="arrow" style="left:41.6667%;"></div>
                <div class="arrow" style="left:58.3333%;"></div>
                <div class="arrow" style="left:75%;"></div>
                <div class="arrow" style="left:91.6667%;"></div>
              </div>

              <!-- Overview grid -->
              <div id="overviewView">
                <div class="bunkers-grid" id="bunkersGrid">
                  <div class="bunker" data-bunker="0"><svg viewBox="0 0 100 150" preserveAspectRatio="xMidYMid meet"></svg><div class="label">Bunker 1</div></div>
                  <div class="bunker" data-bunker="1"><svg viewBox="0 0 100 150" preserveAspectRatio="xMidYMid meet"></svg><div class="label">Bunker 2</div></div>
                  <div class="bunker" data-bunker="2"><svg viewBox="0 0 100 150" preserveAspectRatio="xMidYMid meet"></svg><div class="label">Bunker 3</div></div>
                  <div class="bunker" data-bunker="3"><svg viewBox="0 0 100 150" preserveAspectRatio="xMidYMid meet"></svg><div class="label">Bunker 4</div></div>
                  <div class="bunker" data-bunker="4"><svg viewBox="0 0 100 150" preserveAspectRatio="xMidYMid meet"></svg><div class="label">Bunker 5</div></div>
                  <div class="bunker" data-bunker="5"><svg viewBox="0 0 100 150" preserveAspectRatio="xMidYMid meet"></svg><div class="label">Bunker 6</div></div>
                </div>

                <!-- Coal Flow boxes (ADD BELOW .bunkers-grid) -->
                <div class="coal-flow-wrap">
                 <div class="coal-flow-title">Coal Flow</div>
                 <div class="coal-flow-grid" id="coalFlowGrid">
                  <div class="coal-box" id="coalFlowBox-0" data-bunker="0">
                   <div class="value">--</div>
                   <div class="label">Bunker 1</div>
                  </div>
                  <div class="coal-box" id="coalFlowBox-1" data-bunker="1">
                   <div class="value">--</div>
                   <div class="label">Bunker 2</div>
                  </div>
                  <div class="coal-box" id="coalFlowBox-2" data-bunker="2">
                   <div class="value">--</div>
                   <div class="label">Bunker 3</div>
                  </div>
                  <div class="coal-box" id="coalFlowBox-3" data-bunker="3">
                   <div class="value">--</div>
                   <div class="label">Bunker 4</div>
                  </div>
                  <div class="coal-box" id="coalFlowBox-4" data-bunker="4">
                   <div class="value">--</div>
                   <div class="label">Bunker 5</div>
                  </div>
                  <div class="coal-box" id="coalFlowBox-5" data-bunker="5">
                   <div class="value">--</div>
                   <div class="label">Bunker 6</div>
                  </div>
                 </div>
                </div>
                   <!-- End coal flow boxes -->
                            <!-- Next Blend timers (placed below Coal Flow boxes) -->
                <div class="coal-flow-wrap">
                 <div class="coal-flow-title">Next Blend (timers)</div>
                 <div class="coal-flow-grid" id="nextBlendGrid">
                  <div class="coal-box" id="nextBlendBox-0" data-bunker="0"><div class="value">--</div><div class="label">Bunker 1</div></div>
                  <div class="coal-box" id="nextBlendBox-1" data-bunker="1"><div class="value">--</div><div class="label">Bunker 2</div></div>
                  <div class="coal-box" id="nextBlendBox-2" data-bunker="2"><div class="value">--</div><div class="label">Bunker 3</div></div>
                  <div class="coal-box" id="nextBlendBox-3" data-bunker="3"><div class="value">--</div><div class="label">Bunker 4</div></div>
                  <div class="coal-box" id="nextBlendBox-4" data-bunker="4"><div class="value">--</div><div class="label">Bunker 5</div></div>
                  <div class="coal-box" id="nextBlendBox-5" data-bunker="5"><div class="value">--</div><div class="label">Bunker 6</div></div>
                 </div>
                </div>
                <div class="coal-flow-wrap">
                 <div class="coal-flow-title">Estimated Generation (MW)</div>
                 <div class="coal-flow-grid" id="estGenGrid">
                  <div class="coal-box" id="estGenBox-0" data-bunker="0"><div class="value">--</div><div class="label">Bunker 1</div></div>
                  <div class="coal-box" id="estGenBox-1" data-bunker="1"><div class="value">--</div><div class="label">Bunker 2</div></div>
                  <div class="coal-box" id="estGenBox-2" data-bunker="2"><div class="value">--</div><div class="label">Bunker 3</div></div>
                  <div class="coal-box" id="estGenBox-3" data-bunker="3"><div class="value">--</div><div class="label">Bunker 4</div></div>
                  <div class="coal-box" id="estGenBox-4" data-bunker="4"><div class="value">--</div><div class="label">Bunker 5</div></div>
                  <div class="coal-box" id="estGenBox-5" data-bunker="5"><div class="value">--</div><div class="label">Bunker 6</div></div>
                  </div>
                </div>
              </div>

              <!-- Single bunker view (hidden initially) -->
              <div id="singleView" style="display:none;">
                <div class="single-bunker-wrap">
                  <div class="single-bunker" id="singleBunker">
                    <svg viewBox="0 0 100 150" preserveAspectRatio="xMidYMid meet" id="singleSvg"></svg>
                    <div class="label" id="singleLabel">Bunker 1</div>
                  </div>
                </div>
              </div>

            </div>
          </div>

          <div class="stats-column">
            <div class="stats-panel" id="statsPanel" aria-hidden="false">
              <div style="font-size:13px;font-weight:800;">Summary</div>
              <div class="stat-row"><div class="stat-label">GEN</div><div class="stat-value" id="GEN">--</div></div>
              <div class="stat-row"><div class="stat-label">Flow (TPH)</div><div class="stat-value" id="TOTALFLOW">--</div></div>
              <div class="stat-row"><div class="stat-label">Avg GCV</div><div class="stat-value" id="AVGGCV">--</div></div>
              <div class="stat-row"><div class="stat-label">Avg AFT</div><div class="stat-value" id="AVGAFT">--</div></div>
              <div class="stat-row"><div class="stat-label">Heat Rate</div><div class="stat-value" id="HEATRATE">--</div></div>
              <div class="stat-row"><div class="stat-label">Cost (₹/MT)</div><div class="stat-value" id="COSTRATE">--</div></div>
              <div style="opacity:0.85;font-size:11px;margin-top:6px;"></div>
            </div>
          </div>
        </div>
      </div>
    </main>
  </div>

  <!-- floating tooltip element -->
<div id="coalTooltip" class="coal-tooltip" aria-hidden="true"></div>
<script src="/public/dashboard.js"></script>
<script>
/*
  Coal Flow binder
  - Looks for a flows array (indexes 0..5) and updates the 6 UI boxes:
    #coalFlowBox-0 ... #coalFlowBox-5
  - Usage:
      // start polling every 3s (default)
      startCoalFlowBinder();

      // or start one-time read (no polling)
      startCoalFlowBinder({once:true});

      // Or push new flows instantly from other code:
      window.dispatchEvent(new CustomEvent('flows:update', { detail: { flows: [12.3,9.1,0,4.5,16,7.2] } }));
*/

(function(){
  const BOX_COUNT = 6;
  const BOX_ID_PREFIX = 'coalFlowBox-';

  // ---- DOM updater ----
  function formatFlow(v){
    if (v === null || typeof v === 'undefined' || v === '' ) return '--';
    // if numeric-like, format to one or two decimals as needed
    const n = Number(v);
    if (!Number.isFinite(n)) return String(v);
    // show integer if near integer, else one decimal (adjust as you like)
    return Math.abs(n - Math.round(n)) < 0.005 ? String(Math.round(n)) : Number(n.toFixed(2)).toString();
  }

  function applyFlowsToUI(flows){
    try{
      for(let i=0;i<BOX_COUNT;i++){
        const el = document.getElementById(BOX_ID_PREFIX + i);
        if(!el) continue; // if your markup isn't present yet, skip
        const valEl = el.querySelector('.value');
        const raw = (Array.isArray(flows) && typeof flows[i] !== 'undefined') ? flows[i] : undefined;
        if(valEl) valEl.innerText = (typeof raw === 'undefined' ? '--' : formatFlow(raw));
      }
    }catch(e){ console.error('applyFlowsToUI error', e); }
  }

  // ---- find flows in known globals ----
  function findFlowsInGlobals(){
    try{
      // common suspects (add more if your app uses a different global)
      const suspects = [
        window.flows,
        window.flowsArray,
        window.blend && window.blend.flows,
        window.__INITIAL_DATA__ && window.__INITIAL_DATA__.flows,
        window.__DATA__ && window.__DATA__.flows,
        window.dashboardData && window.dashboardData.flows,
        window.serverData && window.serverData.flows
      ];
      for(const s of suspects){
        if(Array.isArray(s)) return s;
      }
      // also check for object with bunkers -> flows
      if(window.blend && Array.isArray(window.blend.bunkers)){
        // maybe each bunker has .flow property
        const bflows = window.blend.bunkers.map(b => (b && typeof b.flow !== 'undefined') ? b.flow : undefined);
        if(bflows.some(x => typeof x !== 'undefined')) return bflows;
      }
      return null;
    }catch(e){ console.error('findFlowsInGlobals err', e); return null; }
  }

  // ---- fetch flows from likely endpoints ----
  async function fetchFlowsFromEndpoints(){
    const endpoints = ['/api/blend/latest','/api/dashboard'];
    for(const ep of endpoints){
      try{
        const res = await fetch(ep, { method:'GET', credentials:'same-origin' });
        if(!res.ok) continue;
        const j = await res.json();
        // search for flows in various shapes
        if(Array.isArray(j)) {
          // if endpoint returns raw array
          if(j.length >= 0 && j.length <= 100 && (j.length >= 6 || j.length === 6)) return j;
        }
        if(Array.isArray(j.flows)) return j.flows;
        if(Array.isArray(j.data && j.data.flows)) return j.data.flows;
        if(Array.isArray(j.result && j.result.flows)) return j.result.flows;
        // maybe j.rows[0].flows
        if(Array.isArray(j.rows) && j.rows.length && Array.isArray(j.rows[0].flows)) return j.rows[0].flows;
        // maybe j.bunkers -> map .flow
        if(Array.isArray(j.bunkers)) {
          const mapped = j.bunkers.map(b => (b && typeof b.flow !== 'undefined') ? b.flow : undefined);
          if(mapped.some(x => typeof x !== 'undefined')) return mapped;
        }
      }catch(err){
        // ignore fetch errors (CORS, 404 etc) and try next endpoint
        // console.debug('fetch flows ep fail', ep, err);
      }
    }
    return null;
  }

  // ---- master read function ----
  async function readFlows(){
    // 1) try globals
    const g = findFlowsInGlobals();
    if(Array.isArray(g) && g.length) return g;

    // 2) try to read from a known variable inside your dashboard.js (if any)
    // e.g., window.__blendFromServer or window.__BUNKER_DATA__ (common names)
    const extraNames = ['__blendFromServer', '__BUNKER_DATA__', 'initialState'];
    for(const name of extraNames){
      try{
        const val = window[name];
        if(Array.isArray(val)) return val;
        if(val && Array.isArray(val.flows)) return val.flows;
      }catch(e){}
    }

    // 3) try fetch endpoints
    const fetched = await fetchFlowsFromEndpoints();
    if(Array.isArray(fetched) && fetched.length) return fetched;

    // nothing found
    return null;
  }

  // ---- public starter ----
  let _pollTimer = null;
  async function startCoalFlowBinder(opts = {}){
    const { pollInterval = 3000, once = false, immediate = true } = opts;
    if(_pollTimer) clearInterval(_pollTimer);
    if(immediate){
      const flows = await readFlows();
      if(Array.isArray(flows)){
        // ensure length at least BOX_COUNT by filling undefineds
        const normalized = flows.slice(0, BOX_COUNT);
        while(normalized.length < BOX_COUNT) normalized.push(undefined);
        applyFlowsToUI(normalized);
      }else{
        // no flows found in any source right now
        console.warn('CoalFlowBinder: no flows array found in globals or endpoints. UI left with -- values.');
      }
    }
    if(once) return;

    // start polling
    _pollTimer = setInterval(async ()=>{
      try{
        const flows = await readFlows();
        if(Array.isArray(flows)){
          const normalized = flows.slice(0, BOX_COUNT);
          while(normalized.length < BOX_COUNT) normalized.push(undefined);
          applyFlowsToUI(normalized);
        }
      }catch(e){ console.error('poll readFlows err', e); }
    }, Math.max(500, pollInterval));
  }

  function stopCoalFlowBinder(){
    if(_pollTimer) { clearInterval(_pollTimer); _pollTimer = null; }
  }

  // ---- event-based update: other code can dispatch this to immediately update UI ----
  window.addEventListener('flows:update', function(ev){
    try{
      const flows = ev && ev.detail && ev.detail.flows;
      if(Array.isArray(flows)){
        applyFlowsToUI(flows);
      }else{
        console.warn('flows:update event missing detail.flows array');
      }
    }catch(e){ console.error('flows:update handler err', e); }
  }, false);

  // Expose functions to window
  window.applyFlowsToUI = applyFlowsToUI;
  window.readFlows = readFlows;
  window.startCoalFlowBinder = startCoalFlowBinder;
  window.stopCoalFlowBinder = stopCoalFlowBinder;

  // Auto-start by default: attempt immediate bind + polling every 3s.
  // If you don't want auto start, comment the line below.
  startCoalFlowBinder(); // default: poll every 3s

})();
</script>
<script>
/* NextBlendBinder
   - Builds per-bunker sequences from window.LATEST_BLEND.rows (percentages per row)
   - Uses blend.bunkerCapacity and blend.flows (or other flow sources)
   - For bunker i: time = (percent/100 * bunkerCapacity) / flow_i  (hours) -> converted to seconds
   - Each bunker runs its own sequential timers (independent)
*/
(function(){
  const BUNKER_COUNT = 6;
  const BOX_PREFIX = 'nextBlendBox-';
  const POLL_RECOMPUTE_MS = 6000; // re-read blend & flows periodically
  const TICK_MS = 1000; // 1s tick for countdown

  // state per bunker
  const state = Array.from({length: BUNKER_COUNT}, () => ({
    sequence: [],      // durations in seconds
    idx: 0,            // current index in sequence
    remaining: null,   // remaining seconds for current item, null = idle/unavailable
    lastSeqHash: null  // to detect changes
  }));

  // basic time formatter
  function formatHMS(seconds){
    if(seconds === null || typeof seconds === 'undefined' || !Number.isFinite(seconds)) return '--';
    if(seconds <= 0) return '00:00:00';
    seconds = Math.max(0, Math.floor(seconds));
    const h = Math.floor(seconds / 3600);
    const m = Math.floor((seconds % 3600) / 60);
    const s = seconds % 60;
    return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
  }

  // sanitize numeric-like values (handles mongodb wrappers)
  function extractNumber(v){
    if(v === null || typeof v === 'undefined') return null;
    if(typeof v === 'number') return v;
    if(typeof v === 'string' && v.trim() !== '') {
      const n = Number(v);
      return Number.isFinite(n) ? n : null;
    }
    if(typeof v === 'object'){
      // try MongoDB style { $numberInt: "10" } or { $numberDouble: "10.5" }
      if(v.$numberInt) return Number(v.$numberInt);
      if(v.$numberDouble) return Number(v.$numberDouble);
      if(v.$date) return Number(v.$date);
      // fallback to converting JSON string
      try{ const s = JSON.stringify(v); const n = Number(s.replace(/[^\d\.\-]/g,'')); return Number.isFinite(n) ? n : null; }catch(e){}
    }
    return null;
  }

  // compute sequences (durations in seconds) for all bunkers based on blend and flows
  function buildSequencesFromBlend(blend, flows){
    const capacity = (blend && blend.bunkerCapacity) ? extractNumber(blend.bunkerCapacity) : null;
    const seqs = Array.from({length: BUNKER_COUNT}, () => []);
    // choose flows array preference: blend.flows, window.flows, passed flows arg etc
    const flowArr = Array.isArray(flows) ? flows : (Array.isArray(blend && blend.flows) ? blend.flows : (Array.isArray(window.flows) ? window.flows : []));
    for(let b=0;b<BUNKER_COUNT;b++){
      const fVal = extractNumber(flowArr[b]);
      // iterate rows from bottom -> top (reverse) so bottom coal is considered first
      if(!Array.isArray(blend.rows)) { seqs[b] = []; continue; }
      for(let r = blend.rows.length - 1; r >= 0; r--){
        const row = blend.rows[r];
        // prefer row.percentages as array
        let p = null;
        if(Array.isArray(row.percentages) && row.percentages.length > b){
          p = extractNumber(row.percentages[b]);
        } else if(typeof row.percent === 'number' && b === 0) {
          // fallback if row.percent used for single bunker case
          p = row.percent;
        } else if(row.percent) {
          p = extractNumber(row.percent);
        }
        if(p === null || p === 0) continue; // skip zero/no-percent entries
        // require both capacity and flow to compute a duration
        if(!capacity || !fVal || fVal <= 0) {
          seqs[b].push(null); // mark as unavailable due to missing flow/capacity
        } else {
          const percentDecimal = Number(p) / 100.0;
          const hours = (percentDecimal * Number(capacity)) / Number(fVal); // hours
          const seconds = Math.max(0, hours * 3600);
          seqs[b].push(seconds);
        }
      }
    }
    return seqs;
  }

  // update UI for bunker boxes
  function updateNextBlendUI(){
    for(let i=0;i<BUNKER_COUNT;i++){
      const el = document.getElementById(BOX_PREFIX + i);
      if(!el) continue;
      const valEl = el.querySelector('.value');
      const st = state[i];
      if(!st || st.remaining === null || st.remaining === undefined){
        valEl.innerText = '--';
      } else if(st.remaining === 0 && (st.idx >= (st.sequence ? st.sequence.length : 0))){
        valEl.innerText = 'Done';
      } else {
        valEl.innerText = formatHMS(st.remaining);
      }
    }
  }

  // helper to compute a simple hash for a sequence array (to detect changes)
  function seqHash(seq){
    if(!Array.isArray(seq)) return '';
    return seq.map(x => (x === null ? 'X' : Math.round(x))).join(',');
  }

  // attempt to keep current index if sequence changed slightly; otherwise reset to 0
  function reconcileStateWithNewSeq(b, newSeq){
    const st = state[b];
    const newHash = seqHash(newSeq);
    // if sequences identical, keep as is
    if(newHash === st.lastSeqHash) return;
    // if previous index still valid (e.g., lengths match or longer), keep the remaining for current index
    if(Array.isArray(newSeq) && newSeq.length > 0){
      // if previous idx is within newSeq length and remaining less or equal newSeq[idx], keep remaining
      if(st.idx < newSeq.length && st.remaining !== null && st.remaining !== undefined && newSeq[st.idx] !== null){
        // clamp remaining to newSeq[st.idx]
        st.remaining = Math.min(Math.ceil(newSeq[st.idx]), Math.max(0, Math.floor(st.remaining)));
        st.sequence = newSeq.slice();
      } else {
        // reset to first available item
        st.sequence = newSeq.slice();
        st.idx = 0;
        st.remaining = (st.sequence[0] === null || typeof st.sequence[0] === 'undefined') ? null : Math.ceil(st.sequence[0]);
      }
    } else {
      // no sequence
      st.sequence = [];
      st.idx = 0;
      st.remaining = null;
    }
    st.lastSeqHash = newHash;
  }

  // recompute sequences periodically
  function recomputeFromLatest(){
    const blend = window.LATEST_BLEND || null;
    // flows can be from blend.flows or window.flows etc - try to use binder flows first if present
    const flowsCandidates = (Array.isArray(window.__flowsFromBinder) ? window.__flowsFromBinder : null);
    // prefer blend.flows then window.flows then binder candidate
    const flows = Array.isArray(blend && blend.flows) ? blend.flows : (Array.isArray(window.flows) ? window.flows : flowsCandidates);
    const newSeqs = buildSequencesFromBlend(blend || {}, flows || []);
    for(let b=0;b<BUNKER_COUNT;b++){
      reconcileStateWithNewSeq(b, newSeqs[b] || []);
    }
    updateNextBlendUI();
  }

  // 1s tick to decrease remaining for each bunker
  let _tickTimer = null;
  function tick(){
    for(let b=0;b<BUNKER_COUNT;b++){
      const st = state[b];
      if(!st.sequence || st.sequence.length === 0) { st.remaining = null; continue; }
      // if current sequence item is unavailable (null) then mark remaining null
      if(st.sequence[st.idx] === null){
        st.remaining = null;
        continue;
      }
      if(typeof st.remaining !== 'number' || st.remaining <= 0){
        // start / move to next
        if(st.idx < st.sequence.length){
          // set remaining to ceil of sequence entry (if it's a number)
          if(st.sequence[st.idx] === null || typeof st.sequence[st.idx] === 'undefined'){
            st.remaining = null;
          } else {
            st.remaining = Math.max(0, Math.ceil(st.sequence[st.idx]));
          }
        } else {
          st.remaining = 0;
        }
      } else {
        // decrement
        st.remaining = Math.max(0, st.remaining - 1);
        // if reached zero exactly, step to next item on next tick
        if(st.remaining === 0){
          st.idx++;
          if(st.idx < st.sequence.length && st.sequence[st.idx] !== null){
            st.remaining = Math.max(0, Math.ceil(st.sequence[st.idx]));
          } else {
            // either sequence finished or next item unavailable
            if(st.idx >= st.sequence.length) {
              st.remaining = 0;
            } else {
              st.remaining = null;
            }
          }
        }
      }
    }
    updateNextBlendUI();
  }

  // external helper: allow other code to push flows to binder (coal flow binder emits event flows:update)
  function handleFlowsUpdate(ev){
    try{
      const f = ev && ev.detail && ev.detail.flows;
      if(Array.isArray(f)){
        // store a copy so recompute can pick it up
        window.__flowsFromBinder = f.slice(0);
        recomputeFromLatest();
      }
    }catch(e){}
  }

  // auto-listen to flows:update event (coal flow binder uses this)
  window.addEventListener('flows:update', handleFlowsUpdate, false);

  // public controls
  function startNextBlendBinder(){
    if(_tickTimer) return; // already started
    // initial compute
    recomputeFromLatest();
    _tickTimer = setInterval(tick, TICK_MS);
    // recompute sequences at intervals (to pick up new blend data & changed flows)
    window.__nextBlend_recompute_timer = setInterval(recomputeFromLatest, POLL_RECOMPUTE_MS);
    // also run an immediate recompute every time LATEST_BLEND is updated by your code (not strictly necessary)
    // no direct hook available - recompute on interval suffices
  }
  function stopNextBlendBinder(){
    if(_tickTimer) { clearInterval(_tickTimer); _tickTimer = null; }
    if(window.__nextBlend_recompute_timer){ clearInterval(window.__nextBlend_recompute_timer); window.__nextBlend_recompute_timer = null; }
  }

  // Expose for debugging/control
  window.nextBlendBinder = {
    start: startNextBlendBinder,
    stop: stopNextBlendBinder,
    recompute: recomputeFromLatest,
    state
  };

  // auto-start
  document.addEventListener('DOMContentLoaded', () => {
    // small delay so your refreshAndRender may populate window.LATEST_BLEND and flows
    setTimeout(() => { startNextBlendBinder(); }, 800);
  });

})();
</script>
<script>
/* Robust estimatedGenerationBinder with multi-strategy bottom-coal detection + debug table
   MW = (flow_for_bunker) * (gcv_of_bottom_coal) / heatRate
*/
(function(){
  const BUNKER_COUNT = 6;
  const BOX_PREFIX = 'estGenBox-';
  const UPDATE_MS = 1000;

  function extractNumber(v){
    if(v === null || typeof v === 'undefined') return null;
    if(typeof v === 'number') return v;
    if(typeof v === 'string' && v.trim() !== ''){
      const n = Number(String(v).replace(/,/g,''));
      return Number.isFinite(n) ? n : null;
    }
    if(typeof v === 'object'){
      if(v.$numberInt) return Number(v.$numberInt);
      if(v.$numberDouble) return Number(v.$numberDouble);
      if(v.$numberLong) return Number(v.$numberLong);
      if(v.$date) return Number(v.$date);
      try{
        const s = JSON.stringify(v);
        const m = s.match(/-?\d+(\.\d+)?/);
        if(m) {
          const n = Number(m[0]);
          return Number.isFinite(n) ? n : null;
        }
      }catch(e){}
    }
    return null;
  }

  function getFlows(blend){
    if(Array.isArray(blend && blend.flows)) return blend.flows;
    if(Array.isArray(window.flows)) return window.flows;
    if(Array.isArray(window.__flowsFromBinder)) return window.__flowsFromBinder;
    return [];
  }

  // bottom->top list of row indexes that have non-zero percent for a bunker
  function buildRowIndexSeqForBunker(blend, bunkerIndex){
    const seq = [];
    if(!blend || !Array.isArray(blend.rows)) return seq;
    for(let r = blend.rows.length - 1; r >= 0; r--){
      const row = blend.rows[r];
      let p = null;
      if(Array.isArray(row.percentages) && row.percentages.length > bunkerIndex){
        p = extractNumber(row.percentages[bunkerIndex]);
      } else if(typeof row.percent === 'number' && bunkerIndex === 0){
        p = extractNumber(row.percent);
      } else if(row.percent){
        p = extractNumber(row.percent);
      }
      if(p !== null && p !== 0) seq.push(r);
    }
    return seq;
  }

  // try to read HEATRATE from DOM id first, else from blend.heatRate
  function readHeatRate(blend){
    const el = (typeof document !== 'undefined' && document.getElementById) ? document.getElementById('HEATRATE') : null;
    if(el){
      const txt = (el.value !== undefined && el.value !== null) ? el.value : (el.textContent || el.innerText || '');
      const nn = extractNumber(txt);
      if(nn !== null) return nn;
    }
    return extractNumber(blend && blend.heatRate);
  }

  // helper: try to read rowIndex from blend.bunkers[b].layers bottom layer (if present)
  function getRowIndexFromBunkerLayers(blend, bunkerIndex){
    try{
      if(!blend || !Array.isArray(blend.bunkers)) return null;
      const b = blend.bunkers[bunkerIndex];
      if(!b || !Array.isArray(b.layers) || b.layers.length === 0) return null;
      // I assume layers are ordered bottom->top — if wrong, we'll detect it in debug
      const layer = b.layers[0]; // bottom-most layer
      if(layer && (layer.rowIndex !== undefined || layer.rowIndex !== null)) return layer.rowIndex;
      // there might be 'row' or '_id' mapping – attempt common keys
      if(layer && layer.row !== undefined) return layer.row;
    }catch(e){}
    return null;
  }

  // main tick
  function updateOnce(){
    const blend = window.LATEST_BLEND || {};
    const flows = getFlows(blend);
    const heatRate = readHeatRate(blend);

    const debugRows = [];

    for(let b = 0; b < BUNKER_COUNT; b++){
      const box = document.getElementById(BOX_PREFIX + b);
      const valEl = box ? box.querySelector('.value') : null;

      const rawFlow = Array.isArray(flows) ? flows[b] : null;
      const flowVal = extractNumber(rawFlow);

      // strategy 1: map nextBlendBinder.state[b].idx -> rowIndex using same bottom->top sequence
      let chosenRowIndex = null;
      let chosenBy = null;

      const seq = buildRowIndexSeqForBunker(blend, b); // bottom->top row indexes

      if(window.nextBlendBinder && Array.isArray(window.nextBlendBinder.state)){
        const st = window.nextBlendBinder.state[b];
        if(st && Array.isArray(st.sequence)){
          const idx = (typeof st.idx === 'number') ? st.idx : 0;
          if(Array.isArray(seq) && seq.length > 0){
            const safeIdx = Math.min(Math.max(0, idx), seq.length - 1);
            chosenRowIndex = seq[safeIdx];
            chosenBy = 'nextBlendBinder';
          }
        }
      }

      // strategy 2: use blend.bunkers[b].layers bottom-most (if present)
      if(chosenRowIndex === null){
        const rFromLayers = getRowIndexFromBunkerLayers(blend, b);
        if(rFromLayers !== null && rFromLayers !== undefined) {
          chosenRowIndex = rFromLayers;
          chosenBy = 'bunkerLayers';
        }
      }

      // strategy 3: deterministic bottom-most non-zero percent row
      if(chosenRowIndex === null){
        if(Array.isArray(seq) && seq.length > 0){
          chosenRowIndex = seq[0];
          chosenBy = 'bottomScan';
        }
      }

      // get gcv
      const gcv = (chosenRowIndex !== null && Array.isArray(blend.rows) && blend.rows[chosenRowIndex]) ?
                  extractNumber(blend.rows[chosenRowIndex].gcv) : null;

      let computedMw = null;
      if(flowVal !== null && flowVal > 0 && gcv !== null && typeof heatRate === 'number' && heatRate > 0){
        computedMw = (Number(flowVal) * Number(gcv)) / Number(heatRate);
      }

      // update UI
      if(valEl){
        valEl.innerText = (computedMw === null) ? '--' : (Number.isFinite(computedMw) ? computedMw.toFixed(2) : '--');
      }

      debugRows.push({
        bunker: b,
        rawFlow,
        flowVal,
        heatRate,
        seq_rowIndexes: seq,
        chosenBy,
        chosenRowIndex,
        gcv,
        computedMw
      });
    }

    // compact debug table (one-per-second) — inspect in console to see mismatches
    if(console && console.table){
      // show only key fields
      console.log('EstimatedGen — debug');
      console.table(debugRows.map(r => ({
        bunker: r.bunker,
        flowVal: r.flowVal,
        heatRate: r.heatRate,
        seq_rowIndexes: JSON.stringify(r.seq_rowIndexes),
        chosenBy: r.chosenBy,
        chosenRowIndex: r.chosenRowIndex,
        gcv: r.gcv,
        computedMw: (r.computedMw === null ? '--' : Number.isFinite(r.computedMw) ? r.computedMw.toFixed(2) : '--')
      })));
    }
  }

  // lifecycle
  let __timer = null;
  function start(){
    if(__timer) return;
    updateOnce();
    __timer = setInterval(updateOnce, UPDATE_MS);
    window.addEventListener('flows:update', updateOnce);
    window.addEventListener('blend:updated', updateOnce);
  }
  function stop(){
    if(__timer){ clearInterval(__timer); __timer = null; }
    window.removeEventListener('flows:update', updateOnce);
    window.removeEventListener('blend:updated', updateOnce);
  }

  window.estimatedGenerationBinder = { start, stop, update: updateOnce };

  document.addEventListener('DOMContentLoaded', () => setTimeout(start, 600));
})();
</script>
<script>
/*
  Bunker drain visual sync — fixed tooltip/order
  - Keeps visual DOM in top->bottom order (so tooltips and tabs remain correct)
  - Uses nextBlendBinder.sequence (bottom->top) for accurate draining
  - Precomputes visible heights then renders top->bottom so no gaps and correct stacking
*/
(function(){
  const BUNKER_COUNT = 6;
  const topY = 10, midY = 100, bottomY = 140;
  const usableH = bottomY - topY;
  const TICK_MS = 1000;

  const findColor = (typeof findCoalColor === 'function') ? findCoalColor : function(){ return null; };
  const FALLBACK_COLORS = (typeof DEFAULT_COAL_COLORS !== 'undefined') ? DEFAULT_COAL_COLORS : ["#f39c12","#3498db","#2ecc71","#ef4444","#8b5cf6","#14b8a6","#f97316","#06b6d4"];

  function buildFilteredLayers(bdata){
    const layers = Array.isArray(bdata && bdata.layers) ? bdata.layers.slice() : [];
    const filtered = layers.map(l => ({
      coal: l.coal || '',
      percent: (l.percent === undefined || l.percent === null) ? (l.percentages ? l.percentages : 0) : l.percent,
      gcv: (l.gcv !== undefined && l.gcv !== null) ? Number(l.gcv) : null,
      cost: (l.cost !== undefined && l.cost !== null) ? Number(l.cost) : null,
      rowIndex: (typeof l.rowIndex !== 'undefined') ? l.rowIndex : (typeof l.row !== 'undefined' ? l.row : null)
    }));

    const norm = filtered.map(f => {
      let pct = 0;
      if(Array.isArray(f.percent) && f.percent.length) pct = Number(f.percent[0]) || 0;
      else pct = Number(f.percent) || 0;
      return Object.assign({}, f, { percent: pct });
    }).filter(l => l.percent > 0);

    // RETURN TOP->BOTTOM order (original renderer expectation).
    // This preserves tooltip/tab indexing and visual order.
    norm.reverse();
    return norm;
  }

  function getNextBlendStateFor(b){
    if(window.nextBlendBinder && Array.isArray(window.nextBlendBinder.state)){
      return window.nextBlendBinder.state[b] || null;
    }
    return null;
  }

  function updateBunkerDrainVisuals(){
    const blend = window.LATEST_BLEND || {};
    const coalDB = window.COAL_DB || [];
    for(let b=0;b<BUNKER_COUNT;b++){
      const bEl = document.querySelector(`.bunker[data-bunker="${b}"]`);
      if(!bEl) continue;
      const svg = bEl.querySelector('svg');
      if(!svg) continue;

      const bdata = (Array.isArray(blend.bunkers) && blend.bunkers[b]) ? blend.bunkers[b] : { layers: [] };
      const filteredTopToBottom = buildFilteredLayers(bdata); // TOP -> BOTTOM order

      const st = getNextBlendStateFor(b);
      const seq = (st && Array.isArray(st.sequence)) ? st.sequence.slice() : null; // BOTTOM -> TOP
      const curIdx = (st && typeof st.idx === 'number') ? st.idx : null;
      const remaining = (st && typeof st.remaining === 'number') ? st.remaining : null;

      if(!svg.id) svg.id = 'ov_svg_' + b + '_' + Math.random().toString(36).slice(2);
      const clipId = `${svg.id}-clip`;

      const n = filteredTopToBottom.length;
      // compute visible heights per top-index by mapping to bottom-index
      const visibleTop = new Array(n);
      for(let topIdx = 0; topIdx < n; topIdx++){
        const item = filteredTopToBottom[topIdx];
        const pct = Math.max(0, Math.min(100, Number(item.percent) || 0));
        const fullH = (pct / 100) * usableH;

        // map topIdx -> bottomIdx (bottom index 0..n-1)
        const bottomIdx = (n - 1) - topIdx;

        let visibleH = fullH;
        if(Array.isArray(seq) && curIdx !== null && curIdx !== undefined){
          const layerTotal = seq[bottomIdx]; // sequence uses bottom->top indexes
          if(layerTotal === null || typeof layerTotal === 'undefined'){
            visibleH = fullH;
          } else {
            if(bottomIdx < curIdx){
              // bottom layers with index < curIdx are drained
              visibleH = 0;
            } else if(bottomIdx === curIdx && typeof remaining === 'number'){
              const frac = Math.max(0, Math.min(1, Number(remaining) / Math.max(1, Number(layerTotal))));
              visibleH = fullH * frac;
            } else {
              visibleH = fullH;
            }
          }
        }
        visibleTop[topIdx] = visibleH;
      }

      // compute suffix sums for lower layers (sum of visible heights below current topIdx)
      const suffixSum = new Array(n);
      suffixSum[n-1] = 0;
      for(let i = n-2; i >= 0; i--){
        suffixSum[i] = (suffixSum[i+1] || 0) + (visibleTop[i+1] || 0);
      }

      // build svg using top->bottom rendering (so DOM order/tooltips match original)
      let inner = `<defs><clipPath id="${clipId}"><path d="M10 ${topY} L10 ${midY} L45 ${bottomY} L55 ${bottomY} L90 ${midY} L90 ${topY} L10 ${topY}" /></clipPath></defs>`;
      inner += `<path d="M10 ${topY} L10 ${midY} L45 ${bottomY}" stroke="#000" stroke-width="1.3" fill="none" stroke-linecap="round" stroke-linejoin="round" />`;
      inner += `<path d="M90 ${topY} L90 ${midY} L55 ${bottomY}" stroke="#000" stroke-width="1.3" fill="none" stroke-linecap="round" stroke-linejoin="round" />`;

      for(let topIdx = 0; topIdx < n; topIdx++){
        const item = filteredTopToBottom[topIdx];
        const visibleH = visibleTop[topIdx] || 0;
        // y = bottomY - (sum of visible heights of lower layers + visibleH)
        const y = bottomY - ((suffixSum[topIdx] || 0) + visibleH);

        // fallback color mapping uses top-order index (topIdx) to match original DEFAULT_COAL_COLORS usage
        const color = findColor(item.coal, coalDB) || FALLBACK_COLORS[topIdx % FALLBACK_COLORS.length];

        const layerJson = JSON.stringify({ coal: item.coal, percent: item.percent, gcv: item.gcv, cost: item.cost }).replace(/"/g,'&quot;');

        inner += `<g clip-path="url(#${clipId})">` +
                 `<rect x="10" y="${y}" width="80" height="${visibleH}" fill="${color}" data-row="${item.rowIndex}" data-mill="${b}" data-pct="${item.percent}" ` +
                 `onmouseenter="window.showCoalRectTooltip && window.showCoalRectTooltip(event, ${item.rowIndex || 0}, ${b}, ${layerJson})" ` +
                 `onmousemove="window.moveCoalRectTooltip && window.moveCoalRectTooltip(event)" ` +
                 `onmouseleave="window.hideCoalRectTooltip && window.hideCoalRectTooltip()" />` +
                 `</g>`;
      }

      svg.innerHTML = inner;
    }
  }

  document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => { updateBunkerDrainVisuals(); }, 600);
    setInterval(updateBunkerDrainVisuals, TICK_MS);
    window.addEventListener('flows:update', updateBunkerDrainVisuals, false);
    window.addEventListener('blend:updated', updateBunkerDrainVisuals, false);
  });
})();
</script>

<style>
  /* Block table styling (paste into your main <style>) */
  .block-table-wrap { margin-top:10px; width:100%; }
  .block-table {
    width:100%;
    border-collapse:collapse;
    font-size:13px;
    margin-top:6px;
  }
  .block-table thead th {
    text-align:left;
    font-weight:800;
    font-size:12px;
    padding:6px 8px;
    opacity:0.95;
    border-bottom:1px solid rgba(255,255,255,0.08);
  }
  .block-table tbody td {
    padding:6px 8px;
    font-weight:700;
    border-bottom:1px dashed rgba(255,255,255,0.04);
  }

  .block-table {
  width:100%;
  border-collapse:collapse;  /* ensures borders merge cleanly */
  font-size:13px;
  margin-top:6px;
  border:1px solid #fff;     /* outer border */
}

.block-table th,
.block-table td {
  border:1px solid #fff;     /* inner cell borders */
  padding:6px 8px;
  font-weight:700;
  color:#fff;                /* keep text white inside dark panel */
}

.block-table thead th {
  font-weight:800;
  font-size:12px;
  opacity:0.95;
}

  /* Make sure table looks good inside the dark stats-panel */
  #statsPanel .block-table thead th,
  #statsPanel .block-table tbody td { color: #fff; }
  /* subtle background */
  #statsPanel .block-table-wrap { background: rgba(255,255,255,0.02); padding:6px; border-radius:8px; }
  /* small note style */
  .block-table .note { font-weight:600; font-size:11px; opacity:0.9; margin-top:6px; }
</style>

<script>
  (function () {
    // Create and inject table wrapper into #statsPanel
    const statsPanel = document.getElementById('statsPanel');
    if (!statsPanel) return;

    // avoid duplicate insertion
    if (document.getElementById('blockTableWrap')) return;

    const wrap = document.createElement('div');
    wrap.id = 'blockTableWrap';
    wrap.className = 'block-table-wrap';

    wrap.innerHTML = `
      <div style="font-size:13px;font-weight:800;margin-bottom:6px;">Next Blocks</div>
      <table class="block-table" id="blockTable" aria-label="Next blocks table">
        <thead>
          <tr><th style="width:48%;">Block</th><th style="width:26%;">GCV</th><th style="width:26%;">Cost</th></tr>
        </thead>
        <tbody>
          <tr id="blockRow-0"><td class="block-time">--</td><td id="gcv-0">--</td><td id="cost-0">--</td></tr>
          <tr id="blockRow-1"><td class="block-time">--</td><td id="gcv-1">--</td><td id="cost-1">--</td></tr>
          <tr id="blockRow-2"><td class="block-time">--</td><td id="gcv-2">--</td><td id="cost-2">--</td></tr>
          <tr id="blockRow-3"><td class="block-time">--</td><td id="gcv-3">--</td><td id="cost-3">--</td></tr>
        </tbody>
      </table>
      <div class="note" style="color:rgba(255,255,255,0.8);"></div>
    `;

    statsPanel.appendChild(wrap);

    // Helper: format time hh:mm (24h)
    function fmt(date) {
      const hh = String(date.getHours()).padStart(2,'0');
      const mm = String(date.getMinutes()).padStart(2,'0');
      return `${hh}:${mm}`;
    }

    // Compute next quarter-aligned start from now.
    function nextQuarterStart(now) {
      // total minutes including fractional minute from seconds
      const totalMinutes = now.getHours() * 60 + now.getMinutes() + now.getSeconds() / 60;
      // ceil to next multiple of 15 (if already exactly on multiple, this returns that same multiple)
      const startMinutes = Math.ceil(totalMinutes / 15) * 15;
      const h = Math.floor(startMinutes / 60) % 24;
      const m = startMinutes % 60;
      const d = new Date(now.getTime());
      d.setHours(h, m, 0, 0);
      return d;
    }

    // Build the 4 block labels (e.g. "16:45 - 17:00")
    function buildBlockLabels() {
      const now = new Date();
      const firstStart = nextQuarterStart(now);
      const labels = [];
      for (let i = 0; i < 4; i++) {
        const start = new Date(firstStart.getTime() + i * 15 * 60 * 1000);
        const end = new Date(start.getTime() + 15 * 60 * 1000);
        labels.push(`${fmt(start)} - ${fmt(end)}`);
      }
      return labels;
    }

    // Public API: allow other code to populate GCV / Cost for a block index (0..3)
    window.setBlockData = function (index, gcv, cost) {
      if (index < 0 || index > 3) return;
      const gcvCell = document.getElementById(`gcv-${index}`);
      const costCell = document.getElementById(`cost-${index}`);
      if (gcvCell) gcvCell.textContent = (gcv === null || gcv === undefined) ? '--' : String(gcv);
      if (costCell) costCell.textContent = (cost === null || cost === undefined) ? '--' : String(cost);
    };

    // Fill table with calculated times (and keep current GCV/cost cells if set)
    function updateBlockTable() {
      const labels = buildBlockLabels();
      for (let i = 0; i < 4; i++) {
        const row = document.getElementById(`blockRow-${i}`);
        if (!row) continue;
        const timeCell = row.querySelector('.block-time');
        if (timeCell) timeCell.textContent = labels[i];
        // if GCV or cost are empty, keep '--'
        const gcv = document.getElementById(`gcv-${i}`).textContent;
        const cost = document.getElementById(`cost-${i}`).textContent;
        if (!gcv || gcv.trim() === '') document.getElementById(`gcv-${i}`).textContent = '--';
        if (!cost || cost.trim() === '') document.getElementById(`cost-${i}`).textContent = '--';
      }
    }

    // initial render
    updateBlockTable();

    // Update frequently so the "next block" shifts correctly as time passes.
    // Let's update every 10 seconds (cheap). If you want exact boundary behavior
    // we could compute ms until next quarter and setTimeout accordingly
    setInterval(updateBlockTable, 10 * 1000);

    // Optional: update immediately when user clicks your Refresh button
    const refreshBtn = document.getElementById('refreshBtn');
    if (refreshBtn) {
      refreshBtn.addEventListener('click', updateBlockTable);
    }

    // Example: if you already know GCV/cost for the next blocks, set them like:
    // window.setBlockData(0, 5200, 2499); // block 0
    // window.setBlockData(1, 5180, 2480); // block 1
    // ...etc
  })();
</script>



</body>
</html>
