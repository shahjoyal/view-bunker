<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Blend Dashboard â€” Bunkers (8)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
   <style>
    :root{
      /* primary tunables - tweak these to change overall scaling */
      --bg:#F7F8FA; --card:#fff; --muted:#6b7280; --accent:#02008a;
      --sidebar-width:170px;
      --sidebar-collapsed-width:52px;
      --topbar-height:64px;

      /* bunker sizing (clamp will keep heights responsive) */
      --bunker-min-height:160px; --bunker-max-height:460px;
      --bunker-top-line-distance: 46px;
      --arrow-width: 3px;
      --bunker-arrow-height: 90px;
      --arrow-head-size: 12px;

      /* spacing */
      --app-gap:12px;
      --content-padding:12px;
    }

    /* --- Base layout: force app to exactly viewport height and remove page scroll --- */
    html, body {
      height:100%;
      margin:0;
      padding:0;
      width:100%;
      overflow-x:hidden;            /* no horizontal browser scroll */
      overflow-y:hidden;            /* remove vertical browser scroll */
      font-family:Inter, system-ui, Arial, sans-serif;
      background:var(--bg);
      color:#111;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    /* app fills viewport exactly; children must scale internally */
    .app {
      display:flex;
      height:100vh;                 /* lock to viewport */
      gap:var(--app-gap);
      box-sizing:border-box;
    }

    /* sidebar */
    .sidebar {
      width:var(--sidebar-width);
      background:#fff;
      border-right:1px solid rgba(0,0,0,0.04);
      padding:12px 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.03);
      display:flex;
      flex-direction:column;
      gap:6px;
      box-sizing:border-box;
      flex-shrink:0;
      min-width:var(--sidebar-collapsed-width);
      overflow-y:auto;
      max-height:100vh;
      transition:width 220ms ease;
    }
    .sidebar.collapsed { width:var(--sidebar-collapsed-width); }

    .sidebar .title { font-weight:800; color:var(--accent); padding:8px 10px; font-size:13px; }
    .sidebar .item {
      display:flex;
      align-items:center;
      padding:8px 10px;
      border-radius:8px;
      cursor:pointer;
      font-weight:700;
      color:#111;
      font-size:13px;
      gap:8px;
      white-space:nowrap;
    }
    .sidebar .item:hover { background:rgba(2,0,138,0.05); }
    .sidebar .item.active { background:var(--accent); color:#fff; box-shadow:0 6px 18px rgba(2,0,138,0.12); }
    .sidebar .s-icon { width:28px; height:28px; display:inline-flex; align-items:center; justify-content:center; background:rgba(2,0,138,0.06); border-radius:6px; font-weight:800; color:var(--accent); }
    .sidebar .s-label{ display:inline-block; }
    .sidebar.collapsed .s-label { display:none; }

    /* topbar fixed height */
    .topbar {
      height:var(--topbar-height);
      min-height:var(--topbar-height);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      margin-bottom:0;
      flex-shrink:0;
    }
    .topbar .left{
      display:flex; align-items:center; gap:12px;
    }
    .topbar h1{ margin:0; font-size:16px; color:var(--accent); font-weight:800; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .controls{ display:flex; gap:8px; align-items:center; }
    .controls input{ padding:8px 10px; border-radius:8px; border:1px solid #e6e6e6; width:110px; font-size:14px; background:#fff; cursor:pointer; }

    /* hamburger */
    .hamburger{ width:42px; height:36px; display:inline-flex; align-items:center; justify-content:center; cursor:pointer; border-radius:8px; }
    .hamburger:hover{ background:rgba(0,0,0,0.03); }
    .hamburger .lines{ width:18px; height:14px; position:relative; }
    .hamburger .lines span{ position:absolute; left:0; right:0; height:2px; background:#222; border-radius:2px; }
    .hamburger .lines span:nth-child(1){ top:0; }
    .hamburger .lines span:nth-child(2){ top:6px; }
    .hamburger .lines span:nth-child(3){ top:12px; }

    /* layout card becomes a column flex so inner parts can shrink/flow */
    .layout-card{
      background:var(--card);
      border-radius:12px;
      padding:12px;
      box-shadow:0 10px 30px rgba(2,8,23,0.06);
      position:relative;
      overflow:visible;
      display:flex;
      flex-direction:column;
      gap:12px;
      height: calc(100% - var(--topbar-height) - 12px); /* fill remaining main area */
      box-sizing:border-box;
    }

    /* the main row is flexible and will wrap on small heights/widths */
    .layout-row{
      display:flex;
      gap:12px;
      align-items:flex-start;
      flex:1 1 auto;
      min-height:0; /* allow children to shrink */
      flex-wrap:wrap; /* wrap if width is constrained */
    }

    .diagram-column{
      flex:1 1 0;
      min-width:0;
      display:flex;
      flex-direction:column;
      gap:8px;
      min-height:0;
    }
    .stats-column{
      width:160px;
      flex-shrink:0;
      min-width:140px;
    }

    /* stats panel stays visible but will shrink its content */
    .stats-panel{
      width:100%;
      background:#02008a;
      color:#fff;
      padding:8px 10px;
      border-radius:8px;
      box-shadow:0 10px 22px rgba(2,8,23,0.10);
      display:flex;
      flex-direction:column;
      gap:6px;
      z-index:20;
      position:sticky;
      top: calc(var(--topbar-height) + 20px);
      font-size:13px;
    }
    .stat-row{ display:flex; justify-content:space-between; font-weight:700; }
    .stat-label{ opacity:0.95; font-weight:600; font-size:12px; color:rgba(255,255,255,0.95); }
    .stat-value{ font-weight:800; font-size:13px; }

    .diagram-inner { position:relative; padding:8px; min-height:0; display:flex; flex-direction:column; gap:8px; }

    .top-overlay { position: absolute; inset: 0 0 0 0; pointer-events: none; z-index: 90; }
    .top-line { position: absolute; top: var(--bunker-top-line-distance); left: 4%; right: 4%; height: 3px; background: #000; opacity:1; }

    .arrow { position: absolute; width: var(--arrow-width); background: #000; top: calc(var(--bunker-top-line-distance) + 4px); height: var(--bunker-arrow-height); transform-origin: top center; }
    .arrow::after { content: ''; position: absolute; left: calc(50% - 8px); top: 100%; width: 0; height: 0; border-left: 8px solid transparent; border-right: 8px solid transparent; border-top: var(--arrow-head-size) solid #000; }

    /* bunkers grid: allow wrapping so it never forces page size bigger than viewport */
    .bunkers-grid{
      display:flex;
      gap:18px;
      align-items:end;
      padding:18px;
      flex-wrap:wrap;          /* <-- important: wrap to new line if not enough width */
      box-sizing:border-box;
      justify-content:space-between;
      width:100%;
    }

    /* bunker heights will scale within clamp to prevent overflow */
    .bunker{
      position:relative;
      flex:1 1 11%;            /* allow shrink/grow; base width ~11% for 8 columns */
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:flex-end;
      min-width:120px;         /* prevents elements becoming too narrow */
      box-sizing:border-box;
      height: clamp(var(--bunker-min-height), 34vh, var(--bunker-max-height));
      max-height: calc(var(--bunker-max-height));
    }

    /* svg occupies available bunker height but is constrained */
    .bunker svg{ width:100%; height:100%; max-height:100%; display:block; object-fit:contain; }
    .bunker .label{ position:absolute; bottom:5px; left:50%; transform:translateX(-50%); background:rgba(255,255,255,0.98); padding:6px 10px; border-radius:8px; box-shadow:0 2px 10px rgba(0,0,0,0.06); font-weight:700; font-size:13px; white-space:nowrap; }

    /* single-bunker view reduced sizes to avoid overflow */
    .single-bunker-wrap { padding:12px; display:flex; justify-content:center; align-items:flex-start; }
    .single-bunker {
      width:100%;
      max-width:920px;
      height: clamp(240px, 66vh, 720px);
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:flex-end;
      position:relative;
    }
    .single-bunker svg{ width:60%; height:92%; max-height:640px; display:block; }
    .single-bunker .label{ position: absolute; bottom:-30px; left:50%; transform:translateX(-50%); background:rgba(255,255,255,0.98); padding:8px 12px; border-radius:10px; font-weight:800; font-size:16px; white-space:nowrap; }

    /* tooltip */
    .coal-tooltip {
      position: absolute;
      pointer-events: none;
      background: #fff;
      color: #111;
      border: 1px solid rgba(0,0,0,0.12);
      box-shadow: 0 6px 18px rgba(0,0,0,0.12);
      padding: 10px;
      border-radius: 8px;
      font-size: 13px;
      line-height:1.35;
      z-index: 2000;
      display: none;
      min-width: 160px;
    }

    /* ---------- Coal Flow boxes (UI only) ---------- */
    .coal-flow-wrap { margin-top:0; padding:0 0 8px; }
    .coal-flow-title { font-weight:800; margin:6px 18px 8px; color:var(--accent); font-size:14px; }
    .coal-flow-grid { display:flex; gap:12px; align-items:stretch; padding:0 18px; box-sizing:border-box; flex-wrap:wrap; }
    .coal-box {
      flex:1 1 11%;
      min-width:110px;
      height:46px;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      border-radius:10px;
      background:var(--card);
      box-shadow:0 8px 20px rgba(2,8,23,0.06);
      font-weight:800;
      font-size:13px;
      box-sizing:border-box;
    }
    .coal-box .value { font-size:15px; }
    .coal-box .label { font-size:12px; color:var(--muted); font-weight:700; margin-top:4px; }

    /* responsive: stack vertically on narrow screens and shrink heights */
    @media (max-width:1100px){
      .layout-row{ flex-direction:column; gap:10px; }
      .stats-column{ width:100%; order:2; }
      .sidebar{ display:none; } /* hide left sidebar on narrow screens to save space */
      .single-bunker svg{ width:80%; }
      .coal-flow-grid { gap:8px; padding:0 8px; }
      .coal-box { width:100%; flex-basis:auto; }
      .bunkers-grid { padding:8px; gap:10px; }
      .bunker { height: clamp(180px, 30vh, 380px); }
    }

    /* very short viewport (example: small laptop height) â€” make elements more compact */
    @media (max-height:720px){
      :root{
        --bunker-top-line-distance: 36px;
      }
      .bunker { height: clamp(160px, 36vh, 420px); }
      .coal-box { height:48px; }
      .topbar { height:56px; }
      .layout-card { padding:10px; }
    }

    /* ensure no element produces unintended browser scrollbar */
    * { box-sizing:border-box; }

    /* When in single-bunker mode we hide the stats-column and extra overview rows,
   and let the diagram column take the full width. */
.single-mode .stats-column {
  display: none !important;
}

.single-mode .diagram-column {
  flex: 1 1 100% !important;
  min-width: 0;
}

.single-mode .single-bunker svg {
  width: 90% !important;    /* make the single bunker svg wider */
  max-width: 1200px;
}

.single-mode #extraRowWrap,
.single-mode #extraRowGrid {
  display: none !important; /* extra row is hidden in single view just in case */
}

/* ----------------- add/replace these rules inside your <style> ----------------- */

/* topbar title replaced by requirement */
.topbar h1 {
  margin: 0;
  font-size: 16px;
  color: var(--accent);
  font-weight: 800;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

/* controls button styling (Refresh / Logout) */
.controls .btn {
  padding: 8px 12px;
  border-radius: 8px;
  border: 1px solid #e6e6e6;
  background: #fff;
  font-weight: 700;
  cursor: pointer;
  font-size: 14px;
}
.controls .btn:hover{ box-shadow: 0 6px 18px rgba(2,8,23,0.06); }

/* --- make single-bunker use full card width (no artificial max-width) --- */
.single-bunker {
  width: 100%;
  max-width: none;            /* allow full width inside the diagram-column */
  padding: 6px 0;
  display: flex;
  flex-direction: column;
  align-items: stretch;       /* stretch full width */
  justify-content: center;
}

/* svg should occupy the full area available in single view */
.single-bunker svg {
  width: 100% !important;
  height: calc(100% - 48px) !important; /* leave space for the label */
  max-height: none !important;
  display: block;
  object-fit: contain;
}

/* when in single-mode make svg wider if previously overridden */
.single-mode .single-bunker svg {
  width: 100% !important;
}

/* label adjusted to remain centered and not push layout */
.single-bunker .label {
  position: relative;
  bottom: 0;
  margin-top: 8px;
  left: 0;
  transform: none;
  text-align: center;
  display: block;
}

/* ensure layout-card still fits viewport without scrolling */
.layout-card {
  height: calc(100% - var(--topbar-height) - 12px);
  overflow: hidden; /* prevent internal overflow creating scrollbars */
}

/* keep body overflow hidden (already present) to avoid page scroll */
html, body {
  overflow-x: hidden;
  overflow-y: hidden;
}
.logout-btn{
  background: red;
  padding: 8px 12px;
  border-radius: 8px;
  border: 1px solid #e6e6e6;
  background: red;
  font-weight: 700;
  cursor: pointer;
  font-size: 14px;
  color: #F7F8FA;
}

/* ------------------ Make single view fill the diagram card but keep sidebar ------------------ */

/* Ensure the main layout keeps a flexible diagram column like overview */
.main, .content, .diagram-column {
  display: flex;
  flex-direction: column;
  flex: 1 1 auto;       /* take remaining space beside the sidebar */
  width: auto;
  max-width: none;
}

/* Make the container that holds the single view fill the diagram-column */
#singleView {
  display: block;
  width: 100%;
  max-width: none;
  margin: 0;           /* align with card edges */
  padding: 12px 18px;  /* breathing room inside the white card */
  box-sizing: border-box;
  background: transparent;
  box-shadow: none;
}

/* Single-bunker: expand to full available width inside the card */
.single-bunker {
  width: 100%;
  max-width: none;
  padding: 6px 0;
  box-sizing: border-box;
  display: flex;
  flex-direction: column;
  align-items: stretch;   /* stretch the svg to full width */
  justify-content: center;
}

/* SVG should take full width of the single-bunker area and keep aspect ratio */
.single-bunker svg,
#singleSvg {
  width: 100% !important;
  height: auto !important; /* automatic height based on width and viewBox */
  max-height: calc(100vh - var(--topbar-height,64px) - 140px); /* keep it within viewport */
  display: block;
}

/* label below svg stays centered and doesn't affect svg size */
#singleLabel, .single-bunker .label {
  margin-top: 14px;
  text-align: center;
  font-weight: 800;
  font-size: 18px;
}

/* Make sure we do NOT hide or collapse the sidebar in single-mode:
   If you previously added rules hiding the sidebar, remove/comment them:
   e.g. remove/comment any rules like:
     body.single-mode .sidebar { display: none !important; width: 0 !important; }
   or
     .single-mode .diagram-column { width: 100% !important; }
*/

/* ----- Ensure stats panel stays visible and above diagram overlays ----- */
/* Put this near the end of your <style> inside input.html head */
.stats-panel {
  z-index: 999 !important;           /* keep it above top-overlay */
  position: sticky !important;       /* keep sticky behaviour */
  top: calc(var(--topbar-height) + 12px) !important;
}

/* Allow the layout-card to show sticky children (prevent clipping) */
.layout-card {
  overflow: visible !important;
}

/* Ensure stats-column is visible when not intentionally in single-mode */
.app:not(.single-mode) .stats-column {
  display: block !important;
}
/* ------------------ Keep stats panel at the right on desktop ------------------ */
/* Desktop: prevent layout-row wrapping so stats-column stays to the right */
@media (min-width: 1100px) {
  .layout-row {
    flex-wrap: nowrap;            /* prevent second-line wrapping */
    align-items: stretch;
    gap: 12px;
    min-height: 0;
  }

  /* Diagram column takes remaining space and can scroll internally if content is wide */
  .diagram-column {
    flex: 1 1 0;
    min-width: 0;                 /* allow it to shrink below content width */
    overflow: auto;               /* internal scroll if needed; won't push stats down */
    max-height: calc(100% - 0px);
  }

  /* Keep stats fixed width on the right (non-shrinking) */
  .stats-column {
    flex: 0 0 160px;              /* fixed width, wonâ€™t shrink below 160px */
    width: 160px;
    order: 2;                     /* ensure it's the right column */
  }

  /* Bunkers grid should live inside diagram-column and not force whole layout to grow */
  .bunkers-grid {
    box-sizing: border-box;
    flex: 1 1 auto;
    padding-right: 12px;          /* breathing room so right-most items don't hit stats */
    overflow:hidden;            /* internal wrapping of bunkers is still allowed */
  }
}

/* Preserve stacking behaviour on narrow screens (mobile/tablet) */
@media (max-width: 1099px) {
  .layout-row {
    flex-wrap: wrap;
  }
  .stats-column {
    width: 100%;
    order: 2;
    flex: 0 0 auto;
  }
  .diagram-column {
    width: 100%;
    order: 1;
    overflow: visible;
  }
}

/* ---------- Option B (scale-to-fit, no horizontal scroll) ---------- */
.bunkers-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(90px, 1fr));
  gap: 12px;
  align-items: end;
  width: 100%;
}

/* ensure we try to keep 8 columns on larger screens */
@media (min-width: 1300px) {
  .bunkers-grid { grid-template-columns: repeat(8, 1fr); }
}

/* arrow centered inside each bunker */
.bunker .arrow,
.bunker > .arrow {
  left: 50%;
  transform: translateX(-50%);
  position: absolute;
  top: calc(var(--bunker-top-line-distance) + 4px);
}

/* ===== blinking timer styles (paste into your existing <style>) ===== */
@keyframes blink-red-white {
  0%   { background-color: #ffffff; color: #0b0b0b; }
  50%  { background-color: #ff4d4d; color: #ffffff; }
  100% { background-color: #ffffff; color: #0b0b0b; }
}

/* apply animation to the small value node so only timer blinks */
.coal-box .value.blinking {
  animation: blink-red-white 1s linear infinite;
  padding: 2px 6px;          /* small padding so background looks neat */
  border-radius: 6px;
  display: inline-block;     /* keep layout stable */
  box-shadow: 0 4px 12px rgba(255,77,77,0.08);
}

/* optional: a 'done' state styling */
.coal-box .value.done {
  background: #0ea5a0;       /* teal-ish when done */
  color: #fff;
  padding: 2px 6px;
  border-radius: 6px;
  display: inline-block;
}



  </style>

    <script>
     if(localStorage.getItem('isLoggedIn') !== 'true') {
    alert('You must login first!');
    window.location.href = '/public/login.html'; 
} else {
    document.body.style.display = 'block';
}
    function logoutUser() {
  localStorage.setItem('isLoggedIn', 'false'); 
  window.location.href = '/public/login.html'; 
}

  </script>
</head>
<body>
  <div class="app">

    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar">
      <div class="title">Views</div>
      <div class="item active" data-mode="overview" id="tab-overview"><span class="s-icon">O</span><span class="s-label">Overview</span></div>
      <div class="item" data-mode="bunker" data-index="0"><span class="s-icon">1</span><span class="s-label">Bunker 1</span></div>
      <div class="item" data-mode="bunker" data-index="1"><span class="s-icon">2</span><span class="s-label">Bunker 2</span></div>
      <div class="item" data-mode="bunker" data-index="2"><span class="s-icon">3</span><span class="s-label">Bunker 3</span></div>
      <div class="item" data-mode="bunker" data-index="3"><span class="s-icon">4</span><span class="s-label">Bunker 4</span></div>
      <div class="item" data-mode="bunker" data-index="4"><span class="s-icon">5</span><span class="s-label">Bunker 5</span></div>
      <div class="item" data-mode="bunker" data-index="5"><span class="s-icon">6</span><span class="s-label">Bunker 6</span></div>
      <div class="item" data-mode="bunker" data-index="6"><span class="s-icon">7</span><span class="s-label">Bunker 7</span></div>
      <div class="item" data-mode="bunker" data-index="7"><span class="s-icon">8</span><span class="s-label">Bunker 8</span></div>
    </aside>

    <!-- Main -->
    <main class="main">
      <div class="topbar">
       <div class="left">
    <div class="hamburger" id="sidebarToggle" title="Toggle sidebar (click)">
      <div class="lines"><span></span><span></span><span></span></div>
    </div>
    <h1>ABCD-Advanced Bunkering and Coal Database</h1>
       </div>

       <div class="controls">
        <button id="refreshBtn" class="btn" type="button">Refresh</button>
        <button id="logoutBtn" class="logout-btn" type="button" title="Sign out" onclick="logoutUser()">Logout</button>
       </div>
     </div>


      <div class="layout-card">
        <!-- main row -->
        <div class="layout-row">
          <div class="diagram-column">
            <div class="diagram-inner" id="diagramInner">
              <div class="top-overlay" aria-hidden="true" id="topOverlay">
                <div class="top-line" id="topLine"></div>
                <div class="arrow" style="left:6.25%;"></div>
                <div class="arrow" style="left:18.75%;"></div>
                <div class="arrow" style="left:31.25%;"></div>
                <div class="arrow" style="left:43.75%;"></div>
                <div class="arrow" style="left:56.25%;"></div>
                <div class="arrow" style="left:68.75%;"></div>
                <div class="arrow" style="left:81.25%;"></div>
                <div class="arrow" style="left:93.75%;"></div>
              </div>

              <!-- Overview grid -->
              <div id="overviewView">
                <div class="bunkers-grid" id="bunkersGrid">
                  <div class="bunker" data-bunker="0"><svg viewBox="0 0 100 150" preserveAspectRatio="xMidYMid meet"></svg><div class="label">Coal Mill A</div></div>
                  <div class="bunker" data-bunker="1"><svg viewBox="0 0 100 150" preserveAspectRatio="xMidYMid meet"></svg><div class="label">Coal Mill B</div></div>
                  <div class="bunker" data-bunker="2"><svg viewBox="0 0 100 150" preserveAspectRatio="xMidYMid meet"></svg><div class="label">Coal Mill C</div></div>
                  <div class="bunker" data-bunker="3"><svg viewBox="0 0 100 150" preserveAspectRatio="xMidYMid meet"></svg><div class="label">Coal Mill D</div></div>
                  <div class="bunker" data-bunker="4"><svg viewBox="0 0 100 150" preserveAspectRatio="xMidYMid meet"></svg><div class="label">Coal Mill E</div></div>
                  <div class="bunker" data-bunker="5"><svg viewBox="0 0 100 150" preserveAspectRatio="xMidYMid meet"></svg><div class="label">Coal Mill F</div></div>
                  <div class="bunker" data-bunker="6"><svg viewBox="0 0 100 150" preserveAspectRatio="xMidYMid meet"></svg><div class="label">Coal Mill G</div></div>
                  <div class="bunker" data-bunker="7"><svg viewBox="0 0 100 150" preserveAspectRatio="xMidYMid meet"></svg><div class="label">Coal Mill H</div></div>
                </div>

                <!-- Coal Flow boxes (ADD BELOW .bunkers-grid) -->
                <div class="coal-flow-wrap">
                 <div class="coal-flow-title">Coal Flow</div>
                 <div class="coal-flow-grid" id="coalFlowGrid">
                  <div class="coal-box" id="coalFlowBox-0" data-bunker="0">
                   <div class="value">--</div>
                   <div class="label">Coal Mill A</div>
                  </div>
                  <div class="coal-box" id="coalFlowBox-1" data-bunker="1">
                   <div class="value">--</div>
                   <div class="label">Coal Mill B</div>
                  </div>
                  <div class="coal-box" id="coalFlowBox-2" data-bunker="2">
                   <div class="value">--</div>
                   <div class="label">Coal Mill C</div>
                  </div>
                  <div class="coal-box" id="coalFlowBox-3" data-bunker="3">
                   <div class="value">--</div>
                   <div class="label">Coal Mill D</div>
                  </div>
                  <div class="coal-box" id="coalFlowBox-4" data-bunker="4">
                   <div class="value">--</div>
                   <div class="label">Coal Mill E</div>
                  </div>
                  <div class="coal-box" id="coalFlowBox-5" data-bunker="5">
                   <div class="value">--</div>
                   <div class="label">Coal Mill F</div>
                  </div>
                  <div class="coal-box" id="coalFlowBox-6" data-bunker="6">
                   <div class="value">--</div>
                   <div class="label">Coal Mill G</div>
                  </div>
                  <div class="coal-box" id="coalFlowBox-7" data-bunker="7">
                   <div class="value">--</div>
                   <div class="label">Coal Mill H</div>
                  </div>
                 </div>
                </div>
                   <!-- End coal flow boxes -->
                            <!-- Next Blend timers (placed below Coal Flow boxes) -->
                <div class="coal-flow-wrap">
                 <div class="coal-flow-title">Next Coal Batch</div>
                 <div class="coal-flow-grid" id="nextBlendGrid">
                  <div class="coal-box" id="nextBlendBox-0" data-bunker="0"><div class="value">--</div><div class="label">Coal Mill A</div></div>
                  <div class="coal-box" id="nextBlendBox-1" data-bunker="1"><div class="value">--</div><div class="label">Coal Mill B</div></div>
                  <div class="coal-box" id="nextBlendBox-2" data-bunker="2"><div class="value">--</div><div class="label">Coal Mill C</div></div>
                  <div class="coal-box" id="nextBlendBox-3" data-bunker="3"><div class="value">--</div><div class="label">Coal Mill D</div></div>
                  <div class="coal-box" id="nextBlendBox-4" data-bunker="4"><div class="value">--</div><div class="label">Coal Mill E</div></div>
                  <div class="coal-box" id="nextBlendBox-5" data-bunker="5"><div class="value">--</div><div class="label">Coal Mill F</div></div>
                  <div class="coal-box" id="nextBlendBox-6" data-bunker="6"><div class="value">--</div><div class="label">Coal Mill G</div></div>
                  <div class="coal-box" id="nextBlendBox-7" data-bunker="7"><div class="value">--</div><div class="label">Coal Mill H</div></div>
                 </div>
                </div>
                <div class="coal-flow-wrap">
                 <div class="coal-flow-title">Estimated Generation (MW)</div>
                 <div class="coal-flow-grid" id="estGenGrid">
                  <div class="coal-box" id="estGenBox-0" data-bunker="0"><div class="value">--</div><div class="label">Coal Mill A</div></div>
                  <div class="coal-box" id="estGenBox-1" data-bunker="1"><div class="value">--</div><div class="label">Coal Mill B</div></div>
                  <div class="coal-box" id="estGenBox-2" data-bunker="2"><div class="value">--</div><div class="label">Coal Mill C</div></div>
                  <div class="coal-box" id="estGenBox-3" data-bunker="3"><div class="value">--</div><div class="label">Coal Mill D</div></div>
                  <div class="coal-box" id="estGenBox-4" data-bunker="4"><div class="value">--</div><div class="label">Coal Mill E</div></div>
                  <div class="coal-box" id="estGenBox-5" data-bunker="5"><div class="value">--</div><div class="label">Coal Mill F</div></div>
                  <div class="coal-box" id="estGenBox-6" data-bunker="6"><div class="value">--</div><div class="label">Coal Mill G</div></div>
                  <div class="coal-box" id="estGenBox-7" data-bunker="7"><div class="value">--</div><div class="label">Coal Mill H</div></div>
                  </div>
                </div>
                <div class="coal-flow-wrap">
                 <div class="coal-flow-title">Next Coal Batch Estimated Generation(MW) </div>
                 <div class="coal-flow-grid" id="extraRowGrid">
                  <div class="coal-box" id="extraRowBox-0" data-bunker="0"><div class="value">--</div><div class="label">Coal Mill A</div></div>
                  <div class="coal-box" id="extraRowBox-1" data-bunker="1"><div class="value">--</div><div class="label">Coal Mill B</div></div>
                  <div class="coal-box" id="extraRowBox-2" data-bunker="2"><div class="value">--</div><div class="label">Coal Mill C</div></div>
                  <div class="coal-box" id="extraRowBox-3" data-bunker="3"><div class="value">--</div><div class="label">Coal Mill D</div></div>
                  <div class="coal-box" id="extraRowBox-4" data-bunker="4"><div class="value">--</div><div class="label">Coal Mill E</div></div>
                  <div class="coal-box" id="extraRowBox-5" data-bunker="5"><div class="value">--</div><div class="label">Coal Mill F</div></div>
                  <div class="coal-box" id="extraRowBox-6" data-bunker="6"><div class="value">--</div><div class="label">Coal Mill G</div></div>
                  <div class="coal-box" id="extraRowBox-7" data-bunker="7"><div class="value">--</div><div class="label">Coal Mill H</div></div>
                 </div>
                </div>
              </div>

              <!-- Additional row: New row below Estimated Generation -->


             <!-- Single bunker view (hidden initially) -->
              <div id="singleView" style="display:none;">
                <div class="single-bunker-wrap">
                  <div class="single-bunker" id="singleBunker">
                    <svg viewBox="0 0 100 150" preserveAspectRatio="xMidYMid meet" id="singleSvg"></svg>
                    <div class="label" id="singleLabel">Bunker 1</div>
                  </div>
                </div>
              </div>

            </div>
          </div>

          <div class="stats-column">
            <div class="stats-panel" id="statsPanel" aria-hidden="false">
              <div style="font-size:13px;font-weight:800;">Summary</div>
              <div class="stat-row"><div class="stat-label">GEN</div><div class="stat-value" id="GEN">--</div></div>
              <div class="stat-row"><div class="stat-label">Flow (TPH)</div><div class="stat-value" id="TOTALFLOW">--</div></div>
              <div class="stat-row"><div class="stat-label">Avg GCV</div><div class="stat-value" id="AVGGCV">--</div></div>
              <div class="stat-row"><div class="stat-label">Avg AFT</div><div class="stat-value" id="AVGAFT">--</div></div>
              <div class="stat-row"><div class="stat-label">Heat Rate</div><div class="stat-value" id="HEATRATE">--</div></div>
              <div class="stat-row"><div class="stat-label">Average Coal Consumption Cost(â‚¹/MT)</div><div class="stat-value" id="COSTRATE">--</div></div>
              <div style="opacity:0.85;font-size:11px;margin-top:6px;"></div>
            </div>
          </div>
        </div>
      </div>
    </main>
  </div>

  <!-- floating tooltip element -->
<div id="coalTooltip" class="coal-tooltip" aria-hidden="true"></div>
<script src="/public/dashboard.js"></script>
<!-- Inline binders updated to support 8 bunkers -->
<script>
/*
  Coal Flow binder
*/
(function(){
  const BOX_COUNT = 8;
  const BOX_ID_PREFIX = 'coalFlowBox-';

  function formatFlow(v){
    if (v === null || typeof v === 'undefined' || v === '' ) return '--';
    const n = Number(v);
    if (!Number.isFinite(n)) return String(v);
    return Math.abs(n - Math.round(n)) < 0.005 ? String(Math.round(n)) : Number(n.toFixed(2)).toString();
  }

  function applyFlowsToUI(flows){
    try{
      for(let i=0;i<BOX_COUNT;i++){
        const el = document.getElementById(BOX_ID_PREFIX + i);
        if(!el) continue;
        const valEl = el.querySelector('.value');
        const raw = (Array.isArray(flows) && typeof flows[i] !== 'undefined') ? flows[i] : undefined;
        if(valEl) valEl.innerText = (typeof raw === 'undefined' ? '--' : formatFlow(raw));
      }
    }catch(e){ console.error('applyFlowsToUI error', e); }
  }

  function findFlowsInGlobals(){
    try{
      const suspects = [
        window.flows,
        window.flowsArray,
        window.blend && window.blend.flows,
        window.__INITIAL_DATA__ && window.__INITIAL_DATA__.flows,
        window.__DATA__ && window.__DATA__.flows,
        window.dashboardData && window.dashboardData.flows,
        window.serverData && window.serverData.flows
      ];
      for(const s of suspects){ if(Array.isArray(s)) return s; }
      if(window.blend && Array.isArray(window.blend.bunkers)){
        const bflows = window.blend.bunkers.map(b => (b && typeof b.flow !== 'undefined') ? b.flow : undefined);
        if(bflows.some(x => typeof x !== 'undefined')) return bflows;
      }
      return null;
    }catch(e){ console.error('findFlowsInGlobals err', e); return null; }
  }

  async function fetchFlowsFromEndpoints(){
    const endpoints = ['/api/blend/latest','/api/dashboard'];
    for(const ep of endpoints){
      try{
        const res = await fetch(ep, { method:'GET', credentials:'same-origin' });
        if(!res.ok) continue;
        const j = await res.json();
        if(Array.isArray(j)){
          if(j.length >= 0 && (j.length >= BOX_COUNT || j.length === BOX_COUNT)) return j;
        }
        if(Array.isArray(j.flows)) return j.flows;
        if(Array.isArray(j.data && j.data.flows)) return j.data.flows;
        if(Array.isArray(j.result && j.result.flows)) return j.result.flows;
        if(Array.isArray(j.rows) && j.rows.length && Array.isArray(j.rows[0].flows)) return j.rows[0].flows;
        if(Array.isArray(j.bunkers)){
          const mapped = j.bunkers.map(b => (b && typeof b.flow !== 'undefined') ? b.flow : undefined);
          if(mapped.some(x => typeof x !== 'undefined')) return mapped;
        }
      }catch(err){ }
    }
    return null;
  }

  async function readFlows(){
    const g = findFlowsInGlobals(); if(Array.isArray(g) && g.length) return g;
    const extraNames = ['__blendFromServer', '__BUNKER_DATA__', 'initialState'];
    for(const name of extraNames){ try{ const val = window[name]; if(Array.isArray(val)) return val; if(val && Array.isArray(val.flows)) return val.flows; }catch(e){} }
    const fetched = await fetchFlowsFromEndpoints(); if(Array.isArray(fetched) && fetched.length) return fetched;
    return null;
  }

  let _pollTimer = null;
  async function startCoalFlowBinder(opts = {}){
    const { pollInterval = 3000, once = false, immediate = true } = opts;
    if(_pollTimer) clearInterval(_pollTimer);
    if(immediate){
      const flows = await readFlows();
      if(Array.isArray(flows)){
        const normalized = flows.slice(0, BOX_COUNT);
        while(normalized.length < BOX_COUNT) normalized.push(undefined);
        applyFlowsToUI(normalized);
      }else{
        console.warn('CoalFlowBinder: no flows array found in globals or endpoints. UI left with -- values.');
      }
    }
    if(once) return;
    _pollTimer = setInterval(async ()=>{
      try{
        const flows = await readFlows();
        if(Array.isArray(flows)){
          const normalized = flows.slice(0, BOX_COUNT);
          while(normalized.length < BOX_COUNT) normalized.push(undefined);
          applyFlowsToUI(normalized);
        }
      }catch(e){ console.error('poll readFlows err', e); }
    }, Math.max(500, pollInterval));
  }

  function stopCoalFlowBinder(){ if(_pollTimer) { clearInterval(_pollTimer); _pollTimer = null; } }

  window.addEventListener('flows:update', function(ev){
    try{ const flows = ev && ev.detail && ev.detail.flows; if(Array.isArray(flows)){ applyFlowsToUI(flows); }else{ console.warn('flows:update event missing detail.flows array'); } }catch(e){ console.error('flows:update handler err', e); }
  }, false);

  window.applyFlowsToUI = applyFlowsToUI;
  window.readFlows = readFlows;
  window.startCoalFlowBinder = startCoalFlowBinder;
  window.stopCoalFlowBinder = stopCoalFlowBinder;

  startCoalFlowBinder();
})();
</script>
<script>
/* NextBlendBinder (now for 8 bunkers) */
(function(){
  const BUNKER_COUNT = 8;
  const BOX_PREFIX = 'nextBlendBox-';
  const POLL_RECOMPUTE_MS = 6000; // re-read blend & flows periodically
  const TICK_MS = 1000; // 1s tick for countdown

  const state = Array.from({length: BUNKER_COUNT}, () => ({ sequence: [], idx: 0, remaining: null, lastSeqHash: null }));

  function formatHMS(seconds){ if(seconds === null || typeof seconds === 'undefined' || !Number.isFinite(seconds)) return '--'; if(seconds <= 0) return '00:00:00'; seconds = Math.max(0, Math.floor(seconds)); const h = Math.floor(seconds / 3600); const m = Math.floor((seconds % 3600) / 60); const s = seconds % 60; return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`; }

  function extractNumber(v){ if(v === null || typeof v === 'undefined') return null; if(typeof v === 'number') return v; if(typeof v === 'string' && v.trim() !== '') { const n = Number(v); return Number.isFinite(n) ? n : null; } if(typeof v === 'object'){ if(v.$numberInt) return Number(v.$numberInt); if(v.$numberDouble) return Number(v.$numberDouble); if(v.$date) return Number(v.$date); try{ const s = JSON.stringify(v); const n = Number(s.replace(/[^\d\.\-]/g,'')); return Number.isFinite(n) ? n : null; }catch(e){} } return null; }

  function buildSequencesFromBlend(blend, flows){
    const capacity = (blend && blend.bunkerCapacity) ? extractNumber(blend.bunkerCapacity) : null;
    const seqs = Array.from({length: BUNKER_COUNT}, () => []);
    const flowArr = Array.isArray(flows) ? flows : (Array.isArray(blend && blend.flows) ? blend.flows : (Array.isArray(window.flows) ? window.flows : []));
    for(let b=0;b<BUNKER_COUNT;b++){
      const fVal = extractNumber(flowArr[b]);
      if(!Array.isArray(blend.rows)) { seqs[b] = []; continue; }
      for(let r = blend.rows.length - 1; r >= 0; r--){
        const row = blend.rows[r];
        let p = null;
        if(Array.isArray(row.percentages) && row.percentages.length > b){ p = extractNumber(row.percentages[b]); }
        else if(typeof row.percent === 'number' && b === 0) { p = extractNumber(row.percent); }
        else if(row.percent) { p = extractNumber(row.percent); }
        if(p === null || p === 0) continue;
        if(!capacity || !fVal || fVal <= 0) { seqs[b].push(null); } else { const percentDecimal = Number(p) / 100.0; const hours = (percentDecimal * Number(capacity)) / Number(fVal); const seconds = Math.max(0, hours * 3600); seqs[b].push(seconds); }
      }
    }
    return seqs;
  }

function updateNextBlendUI(){
  for(let i=0;i<BUNKER_COUNT;i++){
    const el = document.getElementById(BOX_PREFIX + i);
    if(!el) continue;
    const valEl = el.querySelector('.value');
    const st = state[i];

    // clear classes first (keeps visual state sane)
    if(valEl){
      valEl.classList.remove('blinking');
      valEl.classList.remove('done');
    }

    if(!st || st.remaining === null || st.remaining === undefined){
      if(valEl) valEl.innerText = '--';
    }
    else if(st.remaining === 0 && (st.idx >= (st.sequence ? st.sequence.length : 0))){
      if(valEl){
        valEl.innerText = 'Done';
        // optional: mark done visually (use .done)
        valEl.classList.add('done');
      }
    }
    else {
      if(valEl) valEl.innerText = formatHMS(st.remaining);

      // If less than 1 hour but greater than 0 -> blinking
      if(typeof st.remaining === 'number' && st.remaining > 0 && st.remaining < 3600){
        if(valEl) valEl.classList.add('blinking');
      } else {
        // otherwise ensure blinking removed (already removed above, left for clarity)
        if(valEl) valEl.classList.remove('blinking');
      }
    }
  }
}


  function seqHash(seq){ if(!Array.isArray(seq)) return ''; return seq.map(x => (x === null ? 'X' : Math.round(x))).join(','); }

  function reconcileStateWithNewSeq(b, newSeq){
    const st = state[b];
    const newHash = seqHash(newSeq);
    if(newHash === st.lastSeqHash) return;
    if(Array.isArray(newSeq) && newSeq.length > 0){
      if(st.idx < newSeq.length && st.remaining !== null && st.remaining !== undefined && newSeq[st.idx] !== null){ st.remaining = Math.min(Math.ceil(newSeq[st.idx]), Math.max(0, Math.floor(st.remaining))); st.sequence = newSeq.slice(); }
      else { st.sequence = newSeq.slice(); st.idx = 0; st.remaining = (st.sequence[0] === null || typeof st.sequence[0] === 'undefined') ? null : Math.ceil(st.sequence[0]); }
    } else { st.sequence = []; st.idx = 0; st.remaining = null; }
    st.lastSeqHash = newHash;
  }

  function recomputeFromLatest(){
    const blend = window.LATEST_BLEND || null;
    const flowsCandidates = (Array.isArray(window.__flowsFromBinder) ? window.__flowsFromBinder : null);
    const flows = Array.isArray(blend && blend.flows) ? blend.flows : (Array.isArray(window.flows) ? window.flows : flowsCandidates);
    const newSeqs = buildSequencesFromBlend(blend || {}, flows || []);
    for(let b=0;b<BUNKER_COUNT;b++){ reconcileStateWithNewSeq(b, newSeqs[b] || []); }
    updateNextBlendUI();
  }

  let _tickTimer = null;
  function tick(){
    for(let b=0;b<BUNKER_COUNT;b++){
      const st = state[b];
      if(!st.sequence || st.sequence.length === 0) { st.remaining = null; continue; }
      if(st.sequence[st.idx] === null){ st.remaining = null; continue; }
      if(typeof st.remaining !== 'number' || st.remaining <= 0){
        if(st.idx < st.sequence.length){ if(st.sequence[st.idx] === null || typeof st.sequence[st.idx] === 'undefined'){ st.remaining = null; } else { st.remaining = Math.max(0, Math.ceil(st.sequence[st.idx])); } } else { st.remaining = 0; }
      } else {
        st.remaining = Math.max(0, st.remaining - 1);
        if(st.remaining === 0){ st.idx++; if(st.idx < st.sequence.length && st.sequence[st.idx] !== null){ st.remaining = Math.max(0, Math.ceil(st.sequence[st.idx])); } else { if(st.idx >= st.sequence.length) { st.remaining = 0; } else { st.remaining = null; } } }
      }
    }
    updateNextBlendUI();
  }

  function handleFlowsUpdate(ev){ try{ const f = ev && ev.detail && ev.detail.flows; if(Array.isArray(f)){ window.__flowsFromBinder = f.slice(0); recomputeFromLatest(); } }catch(e){} }
  window.addEventListener('flows:update', handleFlowsUpdate, false);

  function startNextBlendBinder(){ if(_tickTimer) return; recomputeFromLatest(); _tickTimer = setInterval(tick, TICK_MS); window.__nextBlend_recompute_timer = setInterval(recomputeFromLatest, POLL_RECOMPUTE_MS); }
  function stopNextBlendBinder(){ if(_tickTimer) { clearInterval(_tickTimer); _tickTimer = null; } if(window.__nextBlend_recompute_timer){ clearInterval(window.__nextBlend_recompute_timer); window.__nextBlend_recompute_timer = null; } }

  window.nextBlendBinder = { start: startNextBlendBinder, stop: stopNextBlendBinder, recompute: recomputeFromLatest, state };
  document.addEventListener('DOMContentLoaded', () => { setTimeout(() => { startNextBlendBinder(); }, 800); });
})();
</script>
<script>
/* Estimated Generation binder -> supports 8 bunkers */
(function(){
  const BUNKER_COUNT = 8;
  const BOX_PREFIX = 'estGenBox-';
  const UPDATE_MS = 1000;

  function extractNumber(v){ if(v === null || typeof v === 'undefined') return null; if(typeof v === 'number') return v; if(typeof v === 'string' && v.trim() !== ''){ const n = Number(String(v).replace(/,/g,'')); return Number.isFinite(n) ? n : null; } if(typeof v === 'object'){ if(v.$numberInt) return Number(v.$numberInt); if(v.$numberDouble) return Number(v.$numberDouble); if(v.$numberLong) return Number(v.$numberLong); if(v.$date) return Number(v.$date); try{ const s = JSON.stringify(v); const m = s.match(/-?\d+(\.\d+)?/); if(m) { const n = Number(m[0]); return Number.isFinite(n) ? n : null; } }catch(e){} } return null; }

  function getFlows(blend){ if(Array.isArray(blend && blend.flows)) return blend.flows; if(Array.isArray(window.flows)) return window.flows; if(Array.isArray(window.__flowsFromBinder)) return window.__flowsFromBinder; return []; }

  function buildRowIndexSeqForBunker(blend, bunkerIndex){ const seq = []; if(!blend || !Array.isArray(blend.rows)) return seq; for(let r = blend.rows.length - 1; r >= 0; r--){ const row = blend.rows[r]; let p = null; if(Array.isArray(row.percentages) && row.percentages.length > bunkerIndex){ p = extractNumber(row.percentages[bunkerIndex]); } else if(typeof row.percent === 'number' && bunkerIndex === 0){ p = extractNumber(row.percent); } else if(row.percent){ p = extractNumber(row.percent); } if(p !== null && p !== 0) seq.push(r); } return seq; }

  function readHeatRate(blend){ const el = (typeof document !== 'undefined' && document.getElementById) ? document.getElementById('HEATRATE') : null; if(el){ const txt = (el.value !== undefined && el.value !== null) ? el.value : (el.textContent || el.innerText || ''); const nn = extractNumber(txt); if(nn !== null) return nn; } return extractNumber(blend && blend.heatRate); }

  // function getRowIndexFromBunkerLayers(blend, bunkerIndex){ try{ if(!blend || !Array.isArray(blend.bunkers)) return null; const b = blend.bunkers[bunkerIndex]; if(!b || !Array.isArray(b.layers) || b.layers.length === 0) return null; const layer = b.layers[0]; if(layer && (layer.rowIndex !== undefined || layer.rowIndex !== null)) return layer.rowIndex; if(layer && layer.row !== undefined) return layer.row; }catch(e){} return null; }
  function getRowIndexFromBunkerLayers(blend, bunkerIndex){
  try{
    const b = (Array.isArray(blend.bunkers) ? blend.bunkers[bunkerIndex] : null);
    if(!b || !Array.isArray(b.layers) || b.layers.length === 0) return null;

    // iterate bottom-to-top so we prefer the bottom-most visible/active layer
    for(let i = b.layers.length - 1; i >= 0; i--){
      const layer = b.layers[i];
      if(!layer) continue;
      // robust percent extraction (handles percent vs percentages array)
      let rawPct = (layer.percent === undefined || layer.percent === null) ? (layer.percentages ? layer.percentages : 0) : layer.percent;
      let pct = (Array.isArray(rawPct) && rawPct.length) ? Number(rawPct[0]) || 0 : Number(rawPct) || 0;
      if(pct > 0){
        if(layer.rowIndex !== undefined && layer.rowIndex !== null) return layer.rowIndex;
        if(layer.row !== undefined && layer.row !== null) return layer.row;
      }
    }
  }catch(e){}
  return null;
}

  function updateOnce(){
    const blend = window.LATEST_BLEND || {};
    const flows = getFlows(blend);
    const heatRate = readHeatRate(blend);
    for(let b = 0; b < BUNKER_COUNT; b++){
      const box = document.getElementById(BOX_PREFIX + b);
      const valEl = box ? box.querySelector('.value') : null;
      const rawFlow = Array.isArray(flows) ? flows[b] : null;
      const flowVal = extractNumber(rawFlow);
      let chosenRowIndex = null; let chosenBy = null;
      const seq = buildRowIndexSeqForBunker(blend, b);
      if(window.nextBlendBinder && Array.isArray(window.nextBlendBinder.state)){
        const st = window.nextBlendBinder.state[b];
        if(st && Array.isArray(st.sequence)){
          const idx = (typeof st.idx === 'number') ? st.idx : 0;
          if(Array.isArray(seq) && seq.length > 0){ const safeIdx = Math.min(Math.max(0, idx), seq.length - 1); chosenRowIndex = seq[safeIdx]; chosenBy = 'nextBlendBinder'; }
        }
      }
      if(chosenRowIndex === null){ const rFromLayers = getRowIndexFromBunkerLayers(blend, b); if(rFromLayers !== null && rFromLayers !== undefined) { chosenRowIndex = rFromLayers; chosenBy = 'bunkerLayers'; } }
      if(chosenRowIndex === null){ if(Array.isArray(seq) && seq.length > 0){ chosenRowIndex = seq[0]; chosenBy = 'bottomScan'; } }
      // const gcv = (chosenRowIndex !== null && Array.isArray(blend.rows) && blend.rows[chosenRowIndex]) ? extractNumber(blend.rows[chosenRowIndex].gcv) : null;
      // let computedMw = null;
      // if(flowVal !== null && flowVal > 0 && gcv !== null && typeof heatRate === 'number' && heatRate > 0){ computedMw = (Number(flowVal) * Number(gcv)) / Number(heatRate); }
      // if(valEl){ valEl.innerText = (computedMw === null) ? '--' : (Number.isFinite(computedMw) ? computedMw.toFixed(2) : '--'); }
// --- compute GCV for this bunker (prefer per-bunker layer GCV, then per-mill row mapping, then fallback) ---
let gcv = null;
const coalDB = window.COAL_DB || [];

// 1) prefer bottom-most visible layer GCV from blend.bunkers[b].layers (if present)
try {
  if (Array.isArray(blend.bunkers) && blend.bunkers[b] && Array.isArray(blend.bunkers[b].layers)) {
    const layers = blend.bunkers[b].layers;
    // iterate bottom-to-top so we pick the layer that is currently draining
    for (let li = layers.length - 1; li >= 0; li--) {
      const L = layers[li];
      // percent handling (same approach as buildFilteredLayers)
      let rawPct = (L.percent === undefined || L.percent === null) ? (L.percentages ? L.percentages : 0) : L.percent;
      let pctVal = (Array.isArray(rawPct) && rawPct.length) ? extractNumber(rawPct[0]) : extractNumber(rawPct);
      if (pctVal && pctVal > 0) {
        gcv = extractNumber(L.gcv);
        if (gcv === null && L.coal) {
          // try to find coal in DB (match by name or id-like)
          const keyLower = String(L.coal || '').trim().toLowerCase();
          const found = coalDB.find(c => {
            if (!c) return false;
            if (c.coal && String(c.coal).trim().toLowerCase() === keyLower) return true;
            if (c.name && String(c.name).trim().toLowerCase() === keyLower) return true;
            if ((c._id || c.id) && String(c._id || c.id) === String(L.coal)) return true;
            return false;
          });
          if (found) gcv = extractNumber(found.gcv);
        }
        if (gcv !== null) break;
      }
    }
  }
} catch (e) { /* ignore and fallthrough to next options */ }

// 2) if still null, check if the selected row has a per-mill coal mapping (row.coal may be object)
if (gcv === null && chosenRowIndex !== null && Array.isArray(blend.rows) && blend.rows[chosenRowIndex]) {
  try {
    const row = blend.rows[chosenRowIndex];
    if (row && row.coal && typeof row.coal === 'object' && row.coal[String(b)]) {
      const ref = row.coal[String(b)];
      // find in coalDB by name or id
      const keyLower = String(ref || '').trim().toLowerCase();
      const found = coalDB.find(c => {
        if (!c) return false;
        if (c.coal && String(c.coal).trim().toLowerCase() === keyLower) return true;
        if (c.name && String(c.name).trim().toLowerCase() === keyLower) return true;
        if ((c._id || c.id) && String(c._id || c.id) === String(ref)) return true;
        return false;
      });
      if (found) gcv = extractNumber(found.gcv);
    }
  } catch (e) { /* ignore */ }
}

// 3) fallback to the global row gcv
if (gcv === null && chosenRowIndex !== null && Array.isArray(blend.rows) && blend.rows[chosenRowIndex]) {
  gcv = extractNumber(blend.rows[chosenRowIndex].gcv);
}

// 4) compute
let computedMw = null;
if (flowVal !== null && flowVal > 0 && gcv !== null && typeof heatRate === 'number' && heatRate > 0) {
  computedMw = (Number(flowVal) * Number(gcv)) / Number(heatRate);
}
if (valEl) {
  valEl.innerText = (computedMw === null) ? '--' : (Number.isFinite(computedMw) ? computedMw.toFixed(2) : '--');
}

  
  
    }
  }

  let __timer = null;
  function start(){ if(__timer) return; updateOnce(); __timer = setInterval(updateOnce, UPDATE_MS); window.addEventListener('flows:update', updateOnce); window.addEventListener('blend:updated', updateOnce); }
  function stop(){ if(__timer){ clearInterval(__timer); __timer = null; } window.removeEventListener('flows:update', updateOnce); window.removeEventListener('blend:updated', updateOnce); }

  window.estimatedGenerationBinder = { start, stop, update: updateOnce };
  document.addEventListener('DOMContentLoaded', () => setTimeout(start, 600));
})();
</script>
<script>
/* Bunker drain visual sync -> supports 8 bunkers */
(function(){
  const BUNKER_COUNT = 8;
  const topY = 10, midY = 100, bottomY = 140;
  const usableH = bottomY - topY;
  const TICK_MS = 1000;

  const findColor = (typeof findCoalColor === 'function') ? findCoalColor : function(){ return null; };
  const FALLBACK_COLORS = (typeof DEFAULT_COAL_COLORS !== 'undefined') ? DEFAULT_COAL_COLORS : ["#f39c12","#3498db","#2ecc71","#ef4444","#8b5cf6","#14b8a6","#f97316","#06b6d4"];

  // function buildFilteredLayers(bdata){
  //   const layers = Array.isArray(bdata && bdata.layers) ? bdata.layers.slice() : [];
  //   const filtered = layers.map(l => ({ coal: l.coal || '', percent: (l.percent === undefined || l.percent === null) ? (l.percentages ? l.percentages : 0) : l.percent, gcv: (l.gcv !== undefined && l.gcv !== null) ? Number(l.gcv) : null, cost: (l.cost !== undefined && l.cost !== null) ? Number(l.cost) : null, rowIndex: (typeof l.rowIndex !== 'undefined') ? l.rowIndex : (typeof l.row !== 'undefined' ? l.row : null) })); 
  //   const norm = filtered.map(f => { let pct = 0; if(Array.isArray(f.percent) && f.percent.length) pct = Number(f.percent[0]) || 0; else pct = Number(f.percent) || 0; return Object.assign({}, f, { percent: pct }); }).filter(l => l.percent > 0);
  //   norm.reverse(); norm.reverse(); return norm;
  // }

  function buildFilteredLayers(bdata){
  const layers = Array.isArray(bdata && bdata.layers) ? bdata.layers.slice() : [];
  const filtered = layers.map(l => ({
    coal: l.coal || '',
    percent: (l.percent === undefined || l.percent === null) ? (l.percentages ? l.percentages : 0) : l.percent,
    gcv: (l.gcv !== undefined && l.gcv !== null) ? Number(l.gcv) : null,
    cost: (l.cost !== undefined && l.cost !== null) ? Number(l.cost) : null,
    rowIndex: (typeof l.rowIndex !== 'undefined') ? l.rowIndex : (typeof l.row !== 'undefined' ? l.row : null),
    color: (typeof l.color !== 'undefined' && l.color !== null && String(l.color).trim() !== '') 
             ? String(l.color) 
             : (typeof findCoalColor === 'function' ? findCoalColor(l.coal, window.COAL_DB || []) : null)
  })); 
  const norm = filtered.map(f => { let pct = 0; if(Array.isArray(f.percent) && f.percent.length) pct = Number(f.percent[0]) || 0; else pct = Number(f.percent) || 0; return Object.assign({}, f, { percent: pct }); }).filter(l => l.percent > 0);
  norm.reverse(); norm.reverse(); return norm;
}


  function getNextBlendStateFor(b){ if(window.nextBlendBinder && Array.isArray(window.nextBlendBinder.state)){ return window.nextBlendBinder.state[b] || null; } return null; }

  function updateBunkerDrainVisuals(){
    const blend = window.LATEST_BLEND || {};
    const coalDB = window.COAL_DB || [];
    for(let b=0;b<BUNKER_COUNT;b++){
      const bEl = document.querySelector(`.bunker[data-bunker="${b}"]`);
      if(!bEl) continue;
      const svg = bEl.querySelector('svg'); if(!svg) continue;
      const bdata = (Array.isArray(blend.bunkers) && blend.bunkers[b]) ? blend.bunkers[b] : { layers: [] };
      const filteredTopToBottom = buildFilteredLayers(bdata);
      const st = getNextBlendStateFor(b);
      const seq = (st && Array.isArray(st.sequence)) ? st.sequence.slice() : null;
      const curIdx = (st && typeof st.idx === 'number') ? st.idx : null;
      const remaining = (st && typeof st.remaining === 'number') ? st.remaining : null;
      if(!svg.id) svg.id = 'ov_svg_' + b + '_' + Math.random().toString(36).slice(2);
      const clipId = `${svg.id}-clip`;
      const n = filteredTopToBottom.length;
      const visibleTop = new Array(n);
      for(let topIdx = 0; topIdx < n; topIdx++){
        const item = filteredTopToBottom[topIdx];
        const pct = Math.max(0, Math.min(100, Number(item.percent) || 0));
        const fullH = (pct / 100) * usableH;
        const bottomIdx = (n - 1) - topIdx;
        let visibleH = fullH;
        if(Array.isArray(seq) && curIdx !== null && curIdx !== undefined){
          const layerTotal = seq[bottomIdx];
          if(layerTotal === null || typeof layerTotal === 'undefined'){ visibleH = fullH; }
          else { if(bottomIdx < curIdx){ visibleH = 0; } else if(bottomIdx === curIdx && typeof remaining === 'number'){ const frac = Math.max(0, Math.min(1, Number(remaining) / Math.max(1, Number(layerTotal)))); visibleH = fullH * frac; } else { visibleH = fullH; } }
        }
        visibleTop[topIdx] = visibleH;
      }
      const suffixSum = new Array(n);
      suffixSum[n-1] = 0;
      for(let i = n-2; i >= 0; i--){ suffixSum[i] = (suffixSum[i+1] || 0) + (visibleTop[i+1] || 0); }
      let inner = `<defs><clipPath id="${clipId}"><path d="M10 ${topY} L10 ${midY} L45 ${bottomY} L55 ${bottomY} L90 ${midY} L90 ${topY} L10 ${topY}" /></clipPath></defs>`;
      inner += `<path d="M10 ${topY} L10 ${midY} L45 ${bottomY}" stroke="#000" stroke-width="1.3" fill="none" stroke-linecap="round" stroke-linejoin="round" />`;
      inner += `<path d="M90 ${topY} L90 ${midY} L55 ${bottomY}" stroke="#000" stroke-width="1.3" fill="none" stroke-linecap="round" stroke-linejoin="round" />`;
      for(let topIdx = 0; topIdx < n; topIdx++){
        const item = filteredTopToBottom[topIdx];
        const visibleH = visibleTop[topIdx] || 0;
        const y = bottomY - ((suffixSum[topIdx] || 0) + visibleH);
        // const color = findColor(item.coal, coalDB) || FALLBACK_COLORS[topIdx % FALLBACK_COLORS.length];
        const color = (item.color && String(item.color).trim())
            ? String(item.color)
            : (findColor(item.coal, coalDB) || FALLBACK_COLORS[topIdx % FALLBACK_COLORS.length]);
        const layerJson = JSON.stringify({ coal: item.coal, percent: item.percent, gcv: item.gcv, cost: item.cost }).replace(/"/g,'&quot;');
        inner += `<g clip-path="url(#${clipId})">` + `<rect x="10" y="${y}" width="80" height="${visibleH}" fill="${color}" data-row="${item.rowIndex}" data-mill="${b}" data-pct="${item.percent}" ` + `onmouseenter="window.showCoalRectTooltip && window.showCoalRectTooltip(event, ${item.rowIndex || 0}, ${b}, ${layerJson})" ` + `onmousemove="window.moveCoalRectTooltip && window.moveCoalRectTooltip(event)" ` + `onmouseleave="window.hideCoalRectTooltip && window.hideCoalRectTooltip()" />` + `</g>`;
      }
      svg.innerHTML = inner;
    }
  }

  document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => { updateBunkerDrainVisuals(); }, 600);
    setInterval(updateBunkerDrainVisuals, TICK_MS);
    window.addEventListener('flows:update', updateBunkerDrainVisuals, false);
    window.addEventListener('blend:updated', updateBunkerDrainVisuals, false);
  });
})();
</script>

<script>
/* Block table script (GCV & Cost removed, white border added) */
(function () {
  const statsPanel = document.getElementById('statsPanel');
  if (!statsPanel) return;
  if (document.getElementById('blockTableWrap')) return;

  const wrap = document.createElement('div');
  wrap.id = 'blockTableWrap';
  wrap.className = 'block-table-wrap';
  wrap.innerHTML = `
      <div style="font-size:13px;font-weight:800;margin-bottom:6px;">Next Blocks</div>
      <table class="block-table" id="blockTable" aria-label="Next blocks table"
        style="width:100%; border-collapse:collapse; border:1px solid white; color:white;">
        <thead>
          <tr>
            <th style="border:1px solid white; padding:4px;">Block</th>
          </tr>
        </thead>
        <tbody>
          <tr id="blockRow-0"><td class="block-time" style="border:1px solid white; padding:4px;">--</td></tr>
          <tr id="blockRow-1"><td class="block-time" style="border:1px solid white; padding:4px;">--</td></tr>
          <tr id="blockRow-2"><td class="block-time" style="border:1px solid white; padding:4px;">--</td></tr>
          <tr id="blockRow-3"><td class="block-time" style="border:1px solid white; padding:4px;">--</td></tr>
        </tbody>
      </table>
      <div class="note" style="color:rgba(255,255,255,0.8);"></div>
    `;
  statsPanel.appendChild(wrap);

  function fmt(date) {
    const hh = String(date.getHours()).padStart(2, '0');
    const mm = String(date.getMinutes()).padStart(2, '0');
    return `${hh}:${mm}`;
  }

  function nextQuarterStart(now) {
    const totalMinutes = now.getHours() * 60 + now.getMinutes() + now.getSeconds() / 60;
    const startMinutes = Math.ceil(totalMinutes / 15) * 15;
    const h = Math.floor(startMinutes / 60) % 24;
    const m = startMinutes % 60;
    const d = new Date(now.getTime());
    d.setHours(h, m, 0, 0);
    return d;
  }

  function buildBlockLabels() {
    const now = new Date();
    const firstStart = nextQuarterStart(now);
    const labels = [];
    for (let i = 0; i < 4; i++) {
      const start = new Date(firstStart.getTime() + i * 15 * 60 * 1000);
      const end = new Date(start.getTime() + 15 * 60 * 1000);
      labels.push(`${fmt(start)} - ${fmt(end)}`);
    }
    return labels;
  }

  function updateBlockTable() {
    const labels = buildBlockLabels();
    for (let i = 0; i < 4; i++) {
      const row = document.getElementById(`blockRow-${i}`);
      if (!row) continue;
      const timeCell = row.querySelector('.block-time');
      if (timeCell) timeCell.textContent = labels[i];
    }
  }

  updateBlockTable();

  const refreshBtn = document.getElementById('refreshBtn');
  if (refreshBtn) {
    refreshBtn.addEventListener('click', updateBlockTable);
  }
})();
</script>


<script>
/* Wiring: expose tooltip functions and sidebar toggle + adapt sidebar click handlers to new markup */
document.addEventListener('DOMContentLoaded', () => {
  window.showCoalRectTooltip = window.showCoalRectTooltip || function(){};
  window.moveCoalRectTooltip = window.moveCoalRectTooltip || function(){};
  window.hideCoalRectTooltip = window.hideCoalRectTooltip || function(){};

  // sidebar click handlers (items now contain spans)
  document.querySelectorAll('.sidebar .item').forEach(it => {
    it.addEventListener('click', async (e) => {
      const mode = it.dataset.mode;
      const idx = (typeof it.dataset.index !== 'undefined') ? Number(it.dataset.index) : null;
      // remove and set active class
      document.querySelectorAll('.sidebar .item').forEach(it2 => it2.classList.remove('active'));
      it.classList.add('active');
      // call existing functions exposed by your external dashboard.js
      if(typeof setActiveTab === 'function') setActiveTab(mode, idx);
      try{ if(typeof refreshAndRender === 'function') await refreshAndRender(mode, idx || 0); }catch(e){ console.error(e); }
    });
  });

  // refresh button reloads page
  const refreshBtn = document.getElementById('refreshBtn');
  refreshBtn.addEventListener('click', () => location.reload());

  // sidebar toggle (hamburger)
  const sidebarToggle = document.getElementById('sidebarToggle');
  const sidebar = document.getElementById('sidebar');
  if(sidebarToggle && sidebar){
    sidebarToggle.addEventListener('click', () => { sidebar.classList.toggle('collapsed'); });
  }

  // initial render: overview active by default
  if(typeof setActiveTab === 'function') setActiveTab('overview', null);
  if(typeof refreshAndRender === 'function') refreshAndRender('overview', 0).catch(e => console.error(e));

});
</script>
<script>
/* Extra row binder (populates the new Additional Row) */
// (function(){
//   const BOX_COUNT = 8; const PREFIX = 'extraRowBox-';
//   function fmt(v){ if(v===null||typeof v==='undefined') return '--'; const n = Number(String(v).replace(/,/g,'')); if(!Number.isFinite(n)) return String(v); return Math.abs(n - Math.round(n)) < 0.005 ? String(Math.round(n)) : Number(n.toFixed(2)).toString(); }
//   function apply(arr){ for(let i=0;i<BOX_COUNT;i++){ const el = document.getElementById(PREFIX + i); if(!el) continue; const valueEl = el.querySelector('.value'); const raw = (Array.isArray(arr) && typeof arr[i] !== 'undefined') ? arr[i] : undefined; if(valueEl) valueEl.innerText = (typeof raw === 'undefined') ? '--' : fmt(raw); } }
//   function readFromGlobals(){ const candidates = [ window.extraRow, window.__extraRow__, (window.LATEST_BLEND && window.LATEST_BLEND.extraRow), (window.blend && window.blend.extraRow) ]; for(const c of candidates){ if(Array.isArray(c)) return c; } return null; }
//   async function fetchFromApi(){ try{ const res = await fetch('/api/blend/latest'); if(!res.ok) return null; const j = await res.json(); if(Array.isArray(j.extraRow)) return j.extraRow; if(Array.isArray(j.data && j.data.extraRow)) return j.data.extraRow; return null; }catch(e){ return null; } }
//   async function refresh(){ let arr = readFromGlobals(); if(!arr){ arr = await fetchFromApi(); } if(Array.isArray(arr)) apply(arr); }
//   window.addEventListener('flows:update', function(ev){ try{ const ex = ev && ev.detail && ev.detail.extraRow; if(Array.isArray(ex)) apply(ex); }catch(e){} }, false);
//   window.addEventListener('blend:updated', function(){ refresh(); }, false);
//   document.addEventListener('DOMContentLoaded', function(){ setTimeout(refresh, 400); });
// })();
</script>

<script>
document.addEventListener('DOMContentLoaded', () => {
  // existing wiring remains...
  // const logoutBtn = document.getElementById('logoutBtn');
  // if(logoutBtn){
  //   logoutBtn.addEventListener('click', () => {
  //     // simple default behaviour: navigate to /logout endpoint
  //     // you can replace this with any logout API call you prefer
  //     location.href = '/public/login.html';
  //   });
  // }

  // Make sure refresh button doesn't create additional page scroll and triggers the refresh action already coded:
  const refreshBtn = document.getElementById('refreshBtn');
  if(refreshBtn){
    refreshBtn.addEventListener('click', () => {
      // if you want to re-run your refreshAndRender rather than full reload,
      // uncomment the line below (the function exists in dashboard.js):
      // if(typeof refreshAndRender === 'function') refreshAndRender('overview', 0).catch(()=>{});
      // default fallback:
      location.reload();
    });
  }
});
</script>
<script>
document.addEventListener('DOMContentLoaded', () => {
  // Defensive: remove accidental single-mode if present (so stats-column is visible)
  document.body.classList.remove('single-mode');

  // Also ensure the .stats-column element is not hidden by inline styles
  const sc = document.querySelector('.stats-column');
  if (sc) sc.style.display = sc.style.display || 'block';
});
</script>
<!-- <script>
/* Next Coal Batch Estimated Generation (uses GCV of the coal above the bottom-draining layer) */
(function(){
  const BUNKER_COUNT = 8;
  const BOX_PREFIX = 'extraRowBox-';
  const UPDATE_MS = 1000;

  function extractNumber(v){
    if(v === null || typeof v === 'undefined') return null;
    if(typeof v === 'number') return v;
    if(typeof v === 'string' && v.trim() !== ''){
      const n = Number(String(v).replace(/,/g,''));
      return Number.isFinite(n) ? n : null;
    }
    if(typeof v === 'object'){
      if(v.$numberInt) return Number(v.$numberInt);
      if(v.$numberDouble) return Number(v.$numberDouble);
      if(v.$numberLong) return Number(v.$numberLong);
      if(v.$date) return Number(v.$date);
      try{
        const s = JSON.stringify(v);
        const m = s.match(/-?\d+(\.\d+)?/);
        if(m) { const n = Number(m[0]); return Number.isFinite(n) ? n : null; }
      }catch(e){}
    }
    return null;
  }

  function getFlows(blend){
    if(Array.isArray(blend && blend.flows)) return blend.flows;
    if(Array.isArray(window.flows)) return window.flows;
    if(Array.isArray(window.__flowsFromBinder)) return window.__flowsFromBinder;
    return [];
  }

  // same function as in estimatedGenerationBinder (keeps ordering consistent)
  function buildRowIndexSeqForBunker(blend, bunkerIndex){
    const seq = [];
    if(!blend || !Array.isArray(blend.rows)) return seq;
    for(let r = blend.rows.length - 1; r >= 0; r--){
      const row = blend.rows[r];
      let p = null;
      if(Array.isArray(row.percentages) && row.percentages.length > bunkerIndex){
        p = extractNumber(row.percentages[bunkerIndex]);
      } else if(typeof row.percent === 'number' && bunkerIndex === 0){
        p = extractNumber(row.percent);
      } else if(row.percent){
        p = extractNumber(row.percent);
      }
      if(p !== null && p !== 0) seq.push(r);
    }
    return seq;
  }

  function readHeatRate(blend){
    const el = document.getElementById('HEATRATE');
    if(el){
      const txt = (el.value !== undefined && el.value !== null) ? el.value : (el.textContent || el.innerText || '');
      const nn = extractNumber(txt);
      if(nn !== null) return nn;
    }
    return extractNumber(blend && blend.heatRate);
  }

  // Try to pull GCV for a specific rowIndex for a bunker b:
  // - Prefer per-bunker layer gcv if a layer references this rowIndex (and has percent>0)
  // - Then try coal mapping in row.coal -> COAL_DB
  // - Fallback to blend.rows[rowIndex].gcv
  function findGcvForRow(blend, bunkerIndex, rowIndex){
    if(rowIndex === null || typeof rowIndex === 'undefined') return null;
    const coalDB = window.COAL_DB || [];
    try {
      // 1) per-bunker layers
      if (Array.isArray(blend.bunkers) && blend.bunkers[bunkerIndex] && Array.isArray(blend.bunkers[bunkerIndex].layers)){
        const layers = blend.bunkers[bunkerIndex].layers;
        for (let li = 0; li < layers.length; li++){
          const L = layers[li];
          if(!L) continue;
          const Lrow = (typeof L.rowIndex !== 'undefined' && L.rowIndex !== null) ? L.rowIndex : (typeof L.row !== 'undefined' ? L.row : null);
          // consider only layers referencing the target rowIndex and with positive percent
          let rawPct = (L.percent === undefined || L.percent === null) ? (L.percentages ? L.percentages : 0) : L.percent;
          let pctVal = (Array.isArray(rawPct) && rawPct.length) ? extractNumber(rawPct[0]) : extractNumber(rawPct);
          if(Lrow === rowIndex && pctVal && pctVal > 0){
            const gcvL = extractNumber(L.gcv);
            if(gcvL !== null) return gcvL;
            if(L.coal){
              const keyLower = String(L.coal || '').trim().toLowerCase();
              const found = coalDB.find(c => {
                if(!c) return false;
                if(c.coal && String(c.coal).trim().toLowerCase() === keyLower) return true;
                if(c.name && String(c.name).trim().toLowerCase() === keyLower) return true;
                if((c._id || c.id) && String(c._id || c.id) === String(L.coal)) return true;
                return false;
              });
              if(found) return extractNumber(found.gcv);
            }
          }
        }
      }
    } catch(e) { /* ignore and fallback */ }

    // 2) check if row.coal maps to a coal entry (row.coal could e.g. be an object per-mill)
    if(Array.isArray(blend.rows) && blend.rows[rowIndex]){
      try{
        const row = blend.rows[rowIndex];
        if (row && row.coal && typeof row.coal === 'object' && row.coal[String(bunkerIndex)]){
          const ref = row.coal[String(bunkerIndex)];
          const keyLower = String(ref || '').trim().toLowerCase();
          const found = coalDB.find(c => {
            if(!c) return false;
            if(c.coal && String(c.coal).trim().toLowerCase() === keyLower) return true;
            if(c.name && String(c.name).trim().toLowerCase() === keyLower) return true;
            if((c._id || c.id) && String(c._id || c.id) === String(ref)) return true;
            return false;
          });
          if(found) return extractNumber(found.gcv);
        }
      }catch(e){}
    }

    // 3) fallback to global row gcv
    if(Array.isArray(blend.rows) && blend.rows[rowIndex]){
      return extractNumber(blend.rows[rowIndex].gcv);
    }
    return null;
  }

  function updateOnce(){
    const blend = window.LATEST_BLEND || {};
    const flows = getFlows(blend);
    const heatRate = readHeatRate(blend);

    for(let b = 0; b < BUNKER_COUNT; b++){
      const box = document.getElementById(BOX_PREFIX + b);
      const valEl = box ? box.querySelector('.value') : null;
      const rawFlow = Array.isArray(flows) ? flows[b] : null;
      const flowVal = extractNumber(rawFlow);

      // build seq and determine which row is currently draining
      const seq = buildRowIndexSeqForBunker(blend, b); // array of row indices (order consistent with est binder)
      let currentSeqIdx = null;
      if(window.nextBlendBinder && Array.isArray(window.nextBlendBinder.state)){
        const st = window.nextBlendBinder.state[b];
        if(st && Array.isArray(st.sequence)){
          currentSeqIdx = (typeof st.idx === 'number') ? st.idx : 0;
          // clamp
          if(currentSeqIdx < 0) currentSeqIdx = 0;
          if(currentSeqIdx >= seq.length) currentSeqIdx = seq.length - 1;
        }
      } else {
        // default: bottomScan means seq[0] is the active (as estimatedGenerationBinder uses)
        if(seq.length > 0) currentSeqIdx = 0;
      }

      // chosen row for currently draining (mirrors estimatedGenerationBinder behavior)
      const chosenRowIndex = (Array.isArray(seq) && typeof currentSeqIdx === 'number' && seq.length > currentSeqIdx) ? seq[currentSeqIdx] : null;

      // NOW pick the "above" row: the next item in seq (index + 1)
      let aboveRowIndex = null;
      if(Array.isArray(seq) && typeof currentSeqIdx === 'number'){
        const aboveIdx = currentSeqIdx + 1;
        if(aboveIdx >= 0 && aboveIdx < seq.length){
          aboveRowIndex = seq[aboveIdx];
        } else {
          // no above row in the seq (top of stack) => leave null (shows --)
          aboveRowIndex = null;
        }
      }

      // find GCV for the above row
      const gcv = (aboveRowIndex !== null) ? findGcvForRow(blend, b, aboveRowIndex) : null;

      let computedMw = null;
      if (flowVal !== null && flowVal > 0 && gcv !== null && typeof heatRate === 'number' && heatRate > 0){
        computedMw = (Number(flowVal) * Number(gcv)) / Number(heatRate);
      }

      if(valEl){
        valEl.innerText = (computedMw === null) ? '--' : (Number.isFinite(computedMw) ? computedMw.toFixed(2) : '--');
      }
    }
  }

  let __timer = null;
  function start(){
    if(__timer) return;
    updateOnce();
    __timer = setInterval(updateOnce, UPDATE_MS);
    window.addEventListener('flows:update', updateOnce);
    window.addEventListener('blend:updated', updateOnce);
    // also react when nextBlendBinder state changes (if binder exists it updates its own state)
    if(window.nextBlendBinder && Array.isArray(window.nextBlendBinder.state)){
      // attempt to poll that state changes will trigger flows:update or blend:updated already.
      // but also add listener for a custom event if your app dispatches one.
      window.addEventListener('nextBlend:state', updateOnce, false);
    }
  }
  function stop(){
    if(__timer){ clearInterval(__timer); __timer = null; }
    window.removeEventListener('flows:update', updateOnce);
    window.removeEventListener('blend:updated', updateOnce);
    window.removeEventListener('nextBlend:state', updateOnce);
  }

  window.nextBatchEstimatedGenerationBinder = { start, stop, update: updateOnce };
  document.addEventListener('DOMContentLoaded', () => setTimeout(start, 700));
})();
</script> -->
<script>
/* Next Coal Batch Estimated Generation â€” use GCV of the layer just ABOVE the bottom-most (second-last) */
(function(){
  const BUNKER_COUNT = 8;
  const BOX_PREFIX = 'extraRowBox-';
  const UPDATE_MS = 1000;

  function extractNumber(v){
    if(v === null || typeof v === 'undefined') return null;
    if(typeof v === 'number') return v;
    if(typeof v === 'string' && v.trim() !== ''){
      const n = Number(String(v).replace(/,/g,''));
      return Number.isFinite(n) ? n : null;
    }
    if(typeof v === 'object'){
      if(v.$numberInt) return Number(v.$numberInt);
      if(v.$numberDouble) return Number(v.$numberDouble);
      if(v.$numberLong) return Number(v.$numberLong);
      if(v.$date) return Number(v.$date);
      try{
        const s = JSON.stringify(v);
        const m = s.match(/-?\d+(\.\d+)?/);
        if(m) { const n = Number(m[0]); return Number.isFinite(n) ? n : null; }
      }catch(e){}
    }
    return null;
  }

  function getFlows(blend){
    if(Array.isArray(blend && blend.flows)) return blend.flows;
    if(Array.isArray(window.flows)) return window.flows;
    if(Array.isArray(window.__flowsFromBinder)) return window.__flowsFromBinder;
    return [];
  }

  // Resolve GCV for a row index (same fallback order as before)
  function findGcvForRow(blend, bunkerIndex, rowIndex){
    if(rowIndex === null || typeof rowIndex === 'undefined') return null;
    const coalDB = window.COAL_DB || [];
    try {
      if (Array.isArray(blend.bunkers) && blend.bunkers[bunkerIndex] && Array.isArray(blend.bunkers[bunkerIndex].layers)){
        const layers = blend.bunkers[bunkerIndex].layers;
        for (let li = 0; li < layers.length; li++){
          const L = layers[li];
          if(!L) continue;
          const Lrow = (typeof L.rowIndex !== 'undefined' && L.rowIndex !== null) ? L.rowIndex : (typeof L.row !== 'undefined' ? L.row : null);
          let rawPct = (L.percent === undefined || L.percent === null) ? (L.percentages ? L.percentages : 0) : L.percent;
          let pctVal = (Array.isArray(rawPct) && rawPct.length) ? extractNumber(rawPct[0]) : extractNumber(rawPct);
          if(Lrow === rowIndex && pctVal && pctVal > 0){
            const gcvL = extractNumber(L.gcv);
            if(gcvL !== null) return gcvL;
            if(L.coal){
              const keyLower = String(L.coal || '').trim().toLowerCase();
              const found = coalDB.find(c => {
                if(!c) return false;
                if(c.coal && String(c.coal).trim().toLowerCase() === keyLower) return true;
                if(c.name && String(c.name).trim().toLowerCase() === keyLower) return true;
                if((c._id || c.id) && String(c._id || c.id) === String(L.coal)) return true;
                return false;
              });
              if(found) return extractNumber(found.gcv);
            }
          }
        }
      }
    } catch(e) { /* ignore and fallback */ }

    // row.coal -> COAL_DB
    if(Array.isArray(blend.rows) && blend.rows[rowIndex]){
      try{
        const row = blend.rows[rowIndex];
        if (row && row.coal && typeof row.coal === 'object' && row.coal[String(bunkerIndex)]){
          const ref = row.coal[String(bunkerIndex)];
          const keyLower = String(ref || '').trim().toLowerCase();
          const found = coalDB.find(c => {
            if(!c) return false;
            if(c.coal && String(c.coal).trim().toLowerCase() === keyLower) return true;
            if(c.name && String(c.name).trim().toLowerCase() === keyLower) return true;
            if((c._id || c.id) && String(c._id || c.id) === String(ref)) return true;
            return false;
          });
          if(found) return extractNumber(found.gcv);
        }
      }catch(e){}
    }

    // fallback to blend.rows[rowIndex].gcv
    if(Array.isArray(blend.rows) && blend.rows[rowIndex]){
      return extractNumber(blend.rows[rowIndex].gcv);
    }
    return null;
  }

  // Primary: determine the rowIndex of the layer just above the bottom-most visible layer, using bunker.layers
  function getAboveRowIndexFromLayers(blend, bunkerIndex){
    try{
      const b = (Array.isArray(blend.bunkers) ? blend.bunkers[bunkerIndex] : null);
      if(!b || !Array.isArray(b.layers) || b.layers.length === 0) return null;
      // iterate from last -> first to find bottom-most active layer (same approach used by your existing code)
      for(let i = b.layers.length - 1; i >= 0; i--){
        const layer = b.layers[i];
        if(!layer) continue;
        let rawPct = (layer.percent === undefined || layer.percent === null) ? (layer.percentages ? layer.percentages : 0) : layer.percent;
        let pct = (Array.isArray(rawPct) && rawPct.length) ? extractNumber(rawPct[0]) : extractNumber(rawPct);
        if(pct && pct > 0){
          const aboveIdx = i - 1; // layer just above bottom-most
          if(aboveIdx >= 0){
            const L2 = b.layers[aboveIdx];
            if(!L2) return null;
            if(typeof L2.rowIndex !== 'undefined' && L2.rowIndex !== null) return L2.rowIndex;
            if(typeof L2.row !== 'undefined' && L2.row !== null) return L2.row;
            // if no explicit row ref, try to resolve by coal name via COAL_DB matching (if present)
            if(L2.coal){
              const coalDB = window.COAL_DB || [];
              const key = String(L2.coal || '').trim().toLowerCase();
              const found = coalDB.find(c => c && ((c.coal && String(c.coal).trim().toLowerCase() === key) || (c.name && String(c.name).trim().toLowerCase() === key) || (String(c._id||c.id) === String(L2.coal))));
              if(found && typeof found._rowIndex !== 'undefined') return found._rowIndex; // only if you have such mapping
            }
          }
          return null; // bottom existed but nothing above it
        }
      }
    }catch(e){}
    return null;
  }

  // Fallback: pick the row just above the currently draining row using nextBlendBinder.state or seq ordering
  function getAboveRowIndexFromSeq(blend, bunkerIndex){
    const seq = (function(){
      if(!blend || !Array.isArray(blend.rows)) return [];
      const s = [];
      for(let r = blend.rows.length - 1; r >= 0; r--){
        const row = blend.rows[r];
        let p = null;
        if(Array.isArray(row.percentages) && row.percentages.length > bunkerIndex){
          p = extractNumber(row.percentages[bunkerIndex]);
        } else if(typeof row.percent === 'number' && bunkerIndex === 0){
          p = extractNumber(row.percent);
        } else if(row.percent){
          p = extractNumber(row.percent);
        }
        if(p !== null && p !== 0) s.push(r);
      }
      return s;
    })();

    if(window.nextBlendBinder && Array.isArray(window.nextBlendBinder.state)){
      const st = window.nextBlendBinder.state[bunkerIndex];
      if(st && Array.isArray(st.sequence)){
        // st.idx points to the currently draining layer in st.sequence. We want the next one above it.
        const idx = (typeof st.idx === 'number') ? st.idx : 0;
        const aboveIdx = idx + 1;
        if(Array.isArray(st.sequence) && aboveIdx >=0 && aboveIdx < st.sequence.length){
          // st.sequence may be seconds-per-layer, not row indices; try to map via 'seq' computed above
          if(Array.isArray(seq) && seq.length === st.sequence.length){
            return seq[aboveIdx];
          } else {
            // if sequences length mismatch, try to use seq[aboveIdx] directly (best-effort)
            if(Array.isArray(seq) && aboveIdx >=0 && aboveIdx < seq.length) return seq[aboveIdx];
          }
        }
      }
    }

    // fallback: if seq has at least 2 items, pick seq[1] (one above bottom-most)
    if(Array.isArray(seq) && seq.length > 1) return seq[1];
    return null;
  }

  function readHeatRate(blend){
    const el = document.getElementById('HEATRATE');
    if(el){
      const txt = (el.value !== undefined && el.value !== null) ? el.value : (el.textContent || el.innerText || '');
      const nn = extractNumber(txt);
      if(nn !== null) return nn;
    }
    return extractNumber(blend && blend.heatRate);
  }

  function updateOnce(){
    const blend = window.LATEST_BLEND || {};
    const flows = getFlows(blend);
    const heatRate = readHeatRate(blend);

    for(let b = 0; b < BUNKER_COUNT; b++){
      const box = document.getElementById(BOX_PREFIX + b);
      const valEl = box ? box.querySelector('.value') : null;
      const rawFlow = Array.isArray(flows) ? flows[b] : null;
      const flowVal = extractNumber(rawFlow);

      // 1) primary - try to get above-row index from bunker.layers (most reliable)
      let aboveRowIndex = getAboveRowIndexFromLayers(blend, b);

      // 2) fallback - try seq-based approach
      if(aboveRowIndex === null) aboveRowIndex = getAboveRowIndexFromSeq(blend, b);

      // find GCV for that above row
      const gcv = (aboveRowIndex !== null) ? findGcvForRow(blend, b, aboveRowIndex) : null;

      // compute MW: (flow (TPH) * gcv) / heatRate
      let computedMw = null;
      if (flowVal !== null && flowVal > 0 && gcv !== null && typeof heatRate === 'number' && heatRate > 0){
        computedMw = (Number(flowVal) * Number(gcv)) / Number(heatRate);
      }

      if(valEl){
        valEl.innerText = (computedMw === null) ? '--' : (Number.isFinite(computedMw) ? computedMw.toFixed(2) : '--');
      }
      // console.debug('nextBatch', b, { aboveRowIndex, gcv, flowVal, heatRate, computedMw });
    }
  }

  let __timer = null;
  function start(){
    if(__timer) return;
    updateOnce();
    __timer = setInterval(updateOnce, UPDATE_MS);
    window.addEventListener('flows:update', updateOnce);
    window.addEventListener('blend:updated', updateOnce);
    window.addEventListener('nextBlend:state', updateOnce, false);
  }
  function stop(){
    if(__timer){ clearInterval(__timer); __timer = null; }
    window.removeEventListener('flows:update', updateOnce);
    window.removeEventListener('blend:updated', updateOnce);
    window.removeEventListener('nextBlend:state', updateOnce);
  }

  window.nextBatchEstimatedGenerationBinder = { start, stop, update: updateOnce };
  document.addEventListener('DOMContentLoaded', () => setTimeout(start, 700));
})();
</script>

</body>
</html>
