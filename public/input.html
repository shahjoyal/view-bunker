<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Blend Dashboard — Bunkers</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#F7F8FA; --card:#fff; --muted:#6b7280; --accent:#02008a;
      --sidebar-width:170px;
      --bunker-top-line-distance: 46px;
      --arrow-width: 3px;
      --bunker-arrow-height: 220px;
      --arrow-head-size: 12px;
    }

    html,body{ margin:0; padding:0; width:100%; overflow-x:hidden; height:100%; font-family:Inter, system-ui, Arial; background:var(--bg); color:#111; }

    .app {
      display:flex;
      min-height:100vh;
      box-sizing:border-box;
    }

    /* sidebar */
    .sidebar {
      width:var(--sidebar-width);
      background:#fff;
      border-right:1px solid rgba(0,0,0,0.04);
      padding:12px 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.03);
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .sidebar .title { font-weight:800; color:var(--accent); padding:8px 10px; font-size:13px; }
    .sidebar .item {
      display:block;
      padding:8px 10px;
      border-radius:8px;
      cursor:pointer;
      font-weight:700;
      color:#111;
      font-size:13px;
    }
    .sidebar .item:hover { background:rgba(2,0,138,0.05); }
    .sidebar .item.active { background:var(--accent); color:#fff; box-shadow:0 6px 18px rgba(2,0,138,0.12); }

    /* main content */
    .main {
      flex:1;
      padding:12px 18px;
      box-sizing:border-box;
      overflow-y:auto;
    }

    .topbar {
      height:64px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      margin-bottom:8px;
    }
    .topbar h1{ margin:0; font-size:16px; color:var(--accent); font-weight:800; }

    .controls{ display:flex; gap:8px; align-items:center; }
    .controls input{ padding:8px 10px; border-radius:8px; border:1px solid #e6e6e6; width:110px; font-size:14px; background:#fff; cursor:pointer; }

    .layout-card{ background:var(--card); border-radius:12px; padding:12px; box-shadow:0 10px 30px rgba(2,8,23,0.06); position:relative; overflow:visible; }

    .layout-row{ display:flex; gap:12px; align-items:flex-start; }

    .diagram-column{ flex:1 1 auto; min-width:0; }
    .stats-column{ width:160px; flex-shrink:0; }

    /* small compact stats panel */
    .stats-panel{
      width:100%; background:#02008a; color:#fff; padding:8px 10px; border-radius:8px;
      box-shadow:0 10px 22px rgba(2,8,23,0.10);
      display:flex; flex-direction:column; gap:6px; z-index:20;
      position:sticky; top:84px;
      font-size:13px;
    }
    .stat-row{ display:flex; justify-content:space-between; font-weight:700; }
    .stat-label{ opacity:0.95; font-weight:600; font-size:12px; color:rgba(255,255,255,0.95); }
    .stat-value{ font-weight:800; font-size:13px; }

    .diagram-inner { position:relative; padding:8px; }

    .top-overlay { position: absolute; inset: 0 0 0 0; pointer-events: none; z-index: 90; }
    /* top line black (solid) */
    .top-line { position: absolute; top: var(--bunker-top-line-distance); left: 4%; right: 4%; height: 3px; background: #000; opacity:1; }

    .arrow { position: absolute; width: var(--arrow-width); background: #000; top: calc(var(--bunker-top-line-distance) + 4px); height: var(--bunker-arrow-height); transform-origin: top center; }
    .arrow::after { content: ''; position: absolute; left: calc(50% - 8px); top: 100%; width: 0; height: 0; border-left: 8px solid transparent; border-right: 8px solid transparent; border-top: var(--arrow-head-size) solid #000; }

    /* bunkers - use flex so they shrink to fit width, preventing horizontal scroll */
    .bunkers-grid{ display:flex; gap:18px; align-items:end; padding:18px; }
    .bunker{ position:relative; flex:1 1 0; height:520px; display:flex; flex-direction:column; align-items:center; justify-content:flex-end; min-width:0; }
    .bunker svg{ width:100%; height:100%; max-height:480px; display:block; }
    .bunker .label{ position:absolute; bottom:12px; left:50%; transform:translateX(-50%); background:rgba(255,255,255,0.98); padding:6px 10px; border-radius:8px; box-shadow:0 2px 10px rgba(0,0,0,0.06); font-weight:700; font-size:13px; white-space:nowrap; }

    /* single-bunker view reduced height to avoid page scrolling */
    .single-bunker-wrap { padding:20px; display:flex; justify-content:center; align-items:flex-start; }
    .single-bunker { width:100%; max-width:920px; height:66vh; max-height:720px; display:flex; flex-direction:column; align-items:center; justify-content:flex-end; position:relative; }
    .single-bunker svg{ width:60%; height:92%; max-height:640px; display:block; }
    .single-bunker .label{ position: absolute; bottom:20px; left:50%; transform:translateX(-50%); background:rgba(255,255,255,0.98); padding:8px 12px; border-radius:10px; font-weight:800; font-size:16px; }

    /* tooltip */
    .coal-tooltip {
      position: absolute;
      pointer-events: none;
      background: #fff;
      color: #111;
      border: 1px solid rgba(0,0,0,0.12);
      box-shadow: 0 6px 18px rgba(0,0,0,0.12);
      padding: 10px;
      border-radius: 8px;
      font-size: 13px;
      line-height:1.35;
      z-index: 2000;
      display: none;
      min-width: 160px;
    }

    /* ---------- Coal Flow boxes (UI only) ---------- */
.coal-flow-wrap { margin-top:12px; padding:0 0 18px; }
.coal-flow-title { font-weight:800; margin:6px 18px 8px; color:var(--accent); font-size:14px; }
.coal-flow-grid { display:flex; gap:18px; align-items:stretch; padding:0 18px; box-sizing:border-box; }
.coal-box {
  flex:1 1 0;
  min-width:0;
  height:56px;
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  border-radius:10px;
  background:var(--card);
  box-shadow:0 8px 20px rgba(2,8,23,0.06);
  font-weight:800;
  font-size:13px;
}
.coal-box .value { font-size:15px; }
.coal-box .label { font-size:12px; color:var(--muted); font-weight:700; margin-top:4px; }

  /* dims inactive layers and highlights the active (utilising) layer */
  /* .bunker-util .util-inactive { opacity: 0.25; transition: opacity 300ms ease; }
  .bunker-util .util-active   { opacity: 1 !important; transition: opacity 300ms ease; filter: drop-shadow(0 1px 4px rgba(0,0,0,0.25)); } */

/* responsive: stack vertically on narrow screens */
@media (max-width:1100px){
  .coal-flow-grid { flex-direction:column; padding:0 8px; }
  .coal-box { width:100%; height:64px; }
}


    @media (max-width:1100px){
      .layout-row{ flex-direction:column; }
      .stats-column{ width:100%; order:2; }
      .sidebar{ display:none; } /* hide left sidebar on very small screens to save space */
      .single-bunker svg{ width:80%; }
    }
  </style>
</head>
<body>
  <div class="app">

    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar">
      <div class="title">Views</div>
      <div class="item active" data-mode="overview" id="tab-overview">Overview</div>
      <div class="item" data-mode="bunker" data-index="0">Bunker 1</div>
      <div class="item" data-mode="bunker" data-index="1">Bunker 2</div>
      <div class="item" data-mode="bunker" data-index="2">Bunker 3</div>
      <div class="item" data-mode="bunker" data-index="3">Bunker 4</div>
      <div class="item" data-mode="bunker" data-index="4">Bunker 5</div>
      <div class="item" data-mode="bunker" data-index="5">Bunker 6</div>
    </aside>

    <!-- Main -->
    <main class="main">
      <div class="topbar">
        <h1>Blend Dashboard — Bunkers</h1>
        <div class="controls">
          <input id="refreshBtn" type="button" value="Refresh" />
        </div>
      </div>

      <div class="layout-card">
        <!-- main row -->
        <div class="layout-row">
          <div class="diagram-column">
            <div class="diagram-inner" id="diagramInner">
              <div class="top-overlay" aria-hidden="true" id="topOverlay">
                <div class="top-line" id="topLine"></div>
                <div class="arrow" style="left:8.3333%;"></div>
                <div class="arrow" style="left:25%;"></div>
                <div class="arrow" style="left:41.6667%;"></div>
                <div class="arrow" style="left:58.3333%;"></div>
                <div class="arrow" style="left:75%;"></div>
                <div class="arrow" style="left:91.6667%;"></div>
              </div>

              <!-- Overview grid -->
              <div id="overviewView">
                <div class="bunkers-grid" id="bunkersGrid">
                  <div class="bunker" data-bunker="0"><svg viewBox="0 0 100 150" preserveAspectRatio="xMidYMid meet"></svg><div class="label">Bunker 1</div></div>
                  <div class="bunker" data-bunker="1"><svg viewBox="0 0 100 150" preserveAspectRatio="xMidYMid meet"></svg><div class="label">Bunker 2</div></div>
                  <div class="bunker" data-bunker="2"><svg viewBox="0 0 100 150" preserveAspectRatio="xMidYMid meet"></svg><div class="label">Bunker 3</div></div>
                  <div class="bunker" data-bunker="3"><svg viewBox="0 0 100 150" preserveAspectRatio="xMidYMid meet"></svg><div class="label">Bunker 4</div></div>
                  <div class="bunker" data-bunker="4"><svg viewBox="0 0 100 150" preserveAspectRatio="xMidYMid meet"></svg><div class="label">Bunker 5</div></div>
                  <div class="bunker" data-bunker="5"><svg viewBox="0 0 100 150" preserveAspectRatio="xMidYMid meet"></svg><div class="label">Bunker 6</div></div>
                </div>
                <!-- Coal Flow boxes (ADD BELOW .bunkers-grid) -->
                <div class="coal-flow-wrap">
                 <div class="coal-flow-title">Coal Flow</div>
                 <div class="coal-flow-grid" id="coalFlowGrid">
                  <div class="coal-box" id="coalFlowBox-0" data-bunker="0">
                   <div class="value">--</div>
                   <div class="label">Bunker 1</div>
                  </div>
                  <div class="coal-box" id="coalFlowBox-1" data-bunker="1">
                   <div class="value">--</div>
                   <div class="label">Bunker 2</div>
                  </div>
                  <div class="coal-box" id="coalFlowBox-2" data-bunker="2">
                   <div class="value">--</div>
                   <div class="label">Bunker 3</div>
                  </div>
                  <div class="coal-box" id="coalFlowBox-3" data-bunker="3">
                   <div class="value">--</div>
                   <div class="label">Bunker 4</div>
                  </div>
                  <div class="coal-box" id="coalFlowBox-4" data-bunker="4">
                   <div class="value">--</div>
                   <div class="label">Bunker 5</div>
                  </div>
                  <div class="coal-box" id="coalFlowBox-5" data-bunker="5">
                   <div class="value">--</div>
                   <div class="label">Bunker 6</div>
                  </div>
                 </div>
                </div>
                   <!-- End coal flow boxes -->
                            <!-- Next Blend timers (placed below Coal Flow boxes) -->
                <div class="coal-flow-wrap">
                 <div class="coal-flow-title">Next Blend (timers)</div>
                 <div class="coal-flow-grid" id="nextBlendGrid">
                  <div class="coal-box" id="nextBlendBox-0" data-bunker="0"><div class="value">--</div><div class="label">Bunker 1</div></div>
                  <div class="coal-box" id="nextBlendBox-1" data-bunker="1"><div class="value">--</div><div class="label">Bunker 2</div></div>
                  <div class="coal-box" id="nextBlendBox-2" data-bunker="2"><div class="value">--</div><div class="label">Bunker 3</div></div>
                  <div class="coal-box" id="nextBlendBox-3" data-bunker="3"><div class="value">--</div><div class="label">Bunker 4</div></div>
                  <div class="coal-box" id="nextBlendBox-4" data-bunker="4"><div class="value">--</div><div class="label">Bunker 5</div></div>
                  <div class="coal-box" id="nextBlendBox-5" data-bunker="5"><div class="value">--</div><div class="label">Bunker 6</div></div>
                 </div>
                </div>
                <div class="coal-flow-wrap">
                 <div class="coal-flow-title">Estimated Generation (MW)</div>
                 <div class="coal-flow-grid" id="estGenGrid">
                  <div class="coal-box" id="estGenBox-0" data-bunker="0"><div class="value">--</div><div class="label">Bunker 1</div></div>
                  <div class="coal-box" id="estGenBox-1" data-bunker="1"><div class="value">--</div><div class="label">Bunker 2</div></div>
                  <div class="coal-box" id="estGenBox-2" data-bunker="2"><div class="value">--</div><div class="label">Bunker 3</div></div>
                  <div class="coal-box" id="estGenBox-3" data-bunker="3"><div class="value">--</div><div class="label">Bunker 4</div></div>
                  <div class="coal-box" id="estGenBox-4" data-bunker="4"><div class="value">--</div><div class="label">Bunker 5</div></div>
                  <div class="coal-box" id="estGenBox-5" data-bunker="5"><div class="value">--</div><div class="label">Bunker 6</div></div>
                  </div>
                </div>
              </div>

              <!-- Single bunker view (hidden initially) -->
              <div id="singleView" style="display:none;">
                <div class="single-bunker-wrap">
                  <div class="single-bunker" id="singleBunker">
                    <svg viewBox="0 0 100 150" preserveAspectRatio="xMidYMid meet" id="singleSvg"></svg>
                    <div class="label" id="singleLabel">Bunker 1</div>
                  </div>
                </div>
              </div>

            </div>
          </div>

          <div class="stats-column">
            <div class="stats-panel" id="statsPanel" aria-hidden="false">
              <div style="font-size:13px;font-weight:800;">Summary</div>
              <div class="stat-row"><div class="stat-label">GEN</div><div class="stat-value" id="GEN">--</div></div>
              <div class="stat-row"><div class="stat-label">Flow (TPH)</div><div class="stat-value" id="TOTALFLOW">--</div></div>
              <div class="stat-row"><div class="stat-label">Avg GCV</div><div class="stat-value" id="AVGGCV">--</div></div>
              <div class="stat-row"><div class="stat-label">Avg AFT</div><div class="stat-value" id="AVGAFT">--</div></div>
              <div class="stat-row"><div class="stat-label">Heat Rate</div><div class="stat-value" id="HEATRATE">--</div></div>
              <div class="stat-row"><div class="stat-label">Cost (₹/MT)</div><div class="stat-value" id="COSTRATE">--</div></div>
              <div style="opacity:0.85;font-size:11px;margin-top:6px;"></div>
            </div>
          </div>
        </div>
      </div>
    </main>
  </div>

  <!-- floating tooltip element -->
  <div id="coalTooltip" class="coal-tooltip" aria-hidden="true"></div>

  <script src="/public/dashboard.js"></script>
<script>
/*
  Coal Flow binder
  - Looks for a flows array (indexes 0..5) and updates the 6 UI boxes:
    #coalFlowBox-0 ... #coalFlowBox-5
  - Usage:
      // start polling every 3s (default)
      startCoalFlowBinder();

      // or start one-time read (no polling)
      startCoalFlowBinder({once:true});

      // Or push new flows instantly from other code:
      window.dispatchEvent(new CustomEvent('flows:update', { detail: { flows: [12.3,9.1,0,4.5,16,7.2] } }));
*/

(function(){
  const BOX_COUNT = 6;
  const BOX_ID_PREFIX = 'coalFlowBox-';

  // ---- DOM updater ----
  function formatFlow(v){
    if (v === null || typeof v === 'undefined' || v === '' ) return '--';
    // if numeric-like, format to one or two decimals as needed
    const n = Number(v);
    if (!Number.isFinite(n)) return String(v);
    // show integer if near integer, else one decimal (adjust as you like)
    return Math.abs(n - Math.round(n)) < 0.005 ? String(Math.round(n)) : Number(n.toFixed(2)).toString();
  }

  function applyFlowsToUI(flows){
    try{
      for(let i=0;i<BOX_COUNT;i++){
        const el = document.getElementById(BOX_ID_PREFIX + i);
        if(!el) continue; // if your markup isn't present yet, skip
        const valEl = el.querySelector('.value');
        const raw = (Array.isArray(flows) && typeof flows[i] !== 'undefined') ? flows[i] : undefined;
        if(valEl) valEl.innerText = (typeof raw === 'undefined' ? '--' : formatFlow(raw));
      }
    }catch(e){ console.error('applyFlowsToUI error', e); }
  }

  // ---- find flows in known globals ----
  function findFlowsInGlobals(){
    try{
      // common suspects (add more if your app uses a different global)
      const suspects = [
        window.flows,
        window.flowsArray,
        window.blend && window.blend.flows,
        window.__INITIAL_DATA__ && window.__INITIAL_DATA__.flows,
        window.__DATA__ && window.__DATA__.flows,
        window.dashboardData && window.dashboardData.flows,
        window.serverData && window.serverData.flows
      ];
      for(const s of suspects){
        if(Array.isArray(s)) return s;
      }
      // also check for object with bunkers -> flows
      if(window.blend && Array.isArray(window.blend.bunkers)){
        // maybe each bunker has .flow property
        const bflows = window.blend.bunkers.map(b => (b && typeof b.flow !== 'undefined') ? b.flow : undefined);
        if(bflows.some(x => typeof x !== 'undefined')) return bflows;
      }
      return null;
    }catch(e){ console.error('findFlowsInGlobals err', e); return null; }
  }

  // ---- fetch flows from likely endpoints ----
  async function fetchFlowsFromEndpoints(){
    const endpoints = ['/api/blend/latest','/api/dashboard'];
    for(const ep of endpoints){
      try{
        const res = await fetch(ep, { method:'GET', credentials:'same-origin' });
        if(!res.ok) continue;
        const j = await res.json();
        // search for flows in various shapes
        if(Array.isArray(j)) {
          // if endpoint returns raw array
          if(j.length >= 0 && j.length <= 100 && (j.length >= 6 || j.length === 6)) return j;
        }
        if(Array.isArray(j.flows)) return j.flows;
        if(Array.isArray(j.data && j.data.flows)) return j.data.flows;
        if(Array.isArray(j.result && j.result.flows)) return j.result.flows;
        // maybe j.rows[0].flows
        if(Array.isArray(j.rows) && j.rows.length && Array.isArray(j.rows[0].flows)) return j.rows[0].flows;
        // maybe j.bunkers -> map .flow
        if(Array.isArray(j.bunkers)) {
          const mapped = j.bunkers.map(b => (b && typeof b.flow !== 'undefined') ? b.flow : undefined);
          if(mapped.some(x => typeof x !== 'undefined')) return mapped;
        }
      }catch(err){
        // ignore fetch errors (CORS, 404 etc) and try next endpoint
        // console.debug('fetch flows ep fail', ep, err);
      }
    }
    return null;
  }

  // ---- master read function ----
  async function readFlows(){
    // 1) try globals
    const g = findFlowsInGlobals();
    if(Array.isArray(g) && g.length) return g;

    // 2) try to read from a known variable inside your dashboard.js (if any)
    // e.g., window.__blendFromServer or window.__BUNKER_DATA__ (common names)
    const extraNames = ['__blendFromServer', '__BUNKER_DATA__', 'initialState'];
    for(const name of extraNames){
      try{
        const val = window[name];
        if(Array.isArray(val)) return val;
        if(val && Array.isArray(val.flows)) return val.flows;
      }catch(e){}
    }

    // 3) try fetch endpoints
    const fetched = await fetchFlowsFromEndpoints();
    if(Array.isArray(fetched) && fetched.length) return fetched;

    // nothing found
    return null;
  }

  // ---- public starter ----
  let _pollTimer = null;
  async function startCoalFlowBinder(opts = {}){
    const { pollInterval = 3000, once = false, immediate = true } = opts;
    if(_pollTimer) clearInterval(_pollTimer);
    if(immediate){
      const flows = await readFlows();
      if(Array.isArray(flows)){
        // ensure length at least BOX_COUNT by filling undefineds
        const normalized = flows.slice(0, BOX_COUNT);
        while(normalized.length < BOX_COUNT) normalized.push(undefined);
        applyFlowsToUI(normalized);
      }else{
        // no flows found in any source right now
        console.warn('CoalFlowBinder: no flows array found in globals or endpoints. UI left with -- values.');
      }
    }
    if(once) return;

    // start polling
    _pollTimer = setInterval(async ()=>{
      try{
        const flows = await readFlows();
        if(Array.isArray(flows)){
          const normalized = flows.slice(0, BOX_COUNT);
          while(normalized.length < BOX_COUNT) normalized.push(undefined);
          applyFlowsToUI(normalized);
        }
      }catch(e){ console.error('poll readFlows err', e); }
    }, Math.max(500, pollInterval));
  }

  function stopCoalFlowBinder(){
    if(_pollTimer) { clearInterval(_pollTimer); _pollTimer = null; }
  }

  // ---- event-based update: other code can dispatch this to immediately update UI ----
  window.addEventListener('flows:update', function(ev){
    try{
      const flows = ev && ev.detail && ev.detail.flows;
      if(Array.isArray(flows)){
        applyFlowsToUI(flows);
      }else{
        console.warn('flows:update event missing detail.flows array');
      }
    }catch(e){ console.error('flows:update handler err', e); }
  }, false);

  // Expose functions to window
  window.applyFlowsToUI = applyFlowsToUI;
  window.readFlows = readFlows;
  window.startCoalFlowBinder = startCoalFlowBinder;
  window.stopCoalFlowBinder = stopCoalFlowBinder;

  // Auto-start by default: attempt immediate bind + polling every 3s.
  // If you don't want auto start, comment the line below.
  startCoalFlowBinder(); // default: poll every 3s

})();
</script>
<script>
/* NextBlendBinder
   - Builds per-bunker sequences from window.LATEST_BLEND.rows (percentages per row)
   - Uses blend.bunkerCapacity and blend.flows (or other flow sources)
   - For bunker i: time = (percent/100 * bunkerCapacity) / flow_i  (hours) -> converted to seconds
   - Each bunker runs its own sequential timers (independent)
*/
(function(){
  const BUNKER_COUNT = 6;
  const BOX_PREFIX = 'nextBlendBox-';
  const POLL_RECOMPUTE_MS = 6000; // re-read blend & flows periodically
  const TICK_MS = 1000; // 1s tick for countdown

  // state per bunker
  const state = Array.from({length: BUNKER_COUNT}, () => ({
    sequence: [],      // durations in seconds
    idx: 0,            // current index in sequence
    remaining: null,   // remaining seconds for current item, null = idle/unavailable
    lastSeqHash: null  // to detect changes
  }));

  // basic time formatter
  function formatHMS(seconds){
    if(seconds === null || typeof seconds === 'undefined' || !Number.isFinite(seconds)) return '--';
    if(seconds <= 0) return '00:00:00';
    seconds = Math.max(0, Math.floor(seconds));
    const h = Math.floor(seconds / 3600);
    const m = Math.floor((seconds % 3600) / 60);
    const s = seconds % 60;
    return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
  }

  // sanitize numeric-like values (handles mongodb wrappers)
  function extractNumber(v){
    if(v === null || typeof v === 'undefined') return null;
    if(typeof v === 'number') return v;
    if(typeof v === 'string' && v.trim() !== '') {
      const n = Number(v);
      return Number.isFinite(n) ? n : null;
    }
    if(typeof v === 'object'){
      // try MongoDB style { $numberInt: "10" } or { $numberDouble: "10.5" }
      if(v.$numberInt) return Number(v.$numberInt);
      if(v.$numberDouble) return Number(v.$numberDouble);
      if(v.$date) return Number(v.$date);
      // fallback to converting JSON string
      try{ const s = JSON.stringify(v); const n = Number(s.replace(/[^\d\.\-]/g,'')); return Number.isFinite(n) ? n : null; }catch(e){}
    }
    return null;
  }

  // compute sequences (durations in seconds) for all bunkers based on blend and flows
  function buildSequencesFromBlend(blend, flows){
    const capacity = (blend && blend.bunkerCapacity) ? extractNumber(blend.bunkerCapacity) : null;
    const seqs = Array.from({length: BUNKER_COUNT}, () => []);
    // choose flows array preference: blend.flows, window.flows, passed flows arg etc
    const flowArr = Array.isArray(flows) ? flows : (Array.isArray(blend && blend.flows) ? blend.flows : (Array.isArray(window.flows) ? window.flows : []));
    for(let b=0;b<BUNKER_COUNT;b++){
      const fVal = extractNumber(flowArr[b]);
      // iterate rows from bottom -> top (reverse) so bottom coal is considered first
      if(!Array.isArray(blend.rows)) { seqs[b] = []; continue; }
      for(let r = blend.rows.length - 1; r >= 0; r--){
        const row = blend.rows[r];
        // prefer row.percentages as array
        let p = null;
        if(Array.isArray(row.percentages) && row.percentages.length > b){
          p = extractNumber(row.percentages[b]);
        } else if(typeof row.percent === 'number' && b === 0) {
          // fallback if row.percent used for single bunker case
          p = row.percent;
        } else if(row.percent) {
          p = extractNumber(row.percent);
        }
        if(p === null || p === 0) continue; // skip zero/no-percent entries
        // require both capacity and flow to compute a duration
        if(!capacity || !fVal || fVal <= 0) {
          seqs[b].push(null); // mark as unavailable due to missing flow/capacity
        } else {
          const percentDecimal = Number(p) / 100.0;
          const hours = (percentDecimal * Number(capacity)) / Number(fVal); // hours
          const seconds = Math.max(0, hours * 3600);
          seqs[b].push(seconds);
        }
      }
    }
    return seqs;
  }

  // update UI for bunker boxes
  function updateNextBlendUI(){
    for(let i=0;i<BUNKER_COUNT;i++){
      const el = document.getElementById(BOX_PREFIX + i);
      if(!el) continue;
      const valEl = el.querySelector('.value');
      const st = state[i];
      if(!st || st.remaining === null || st.remaining === undefined){
        valEl.innerText = '--';
      } else if(st.remaining === 0 && (st.idx >= (st.sequence ? st.sequence.length : 0))){
        valEl.innerText = 'Done';
      } else {
        valEl.innerText = formatHMS(st.remaining);
      }
    }
  }

  // helper to compute a simple hash for a sequence array (to detect changes)
  function seqHash(seq){
    if(!Array.isArray(seq)) return '';
    return seq.map(x => (x === null ? 'X' : Math.round(x))).join(',');
  }

  // attempt to keep current index if sequence changed slightly; otherwise reset to 0
  function reconcileStateWithNewSeq(b, newSeq){
    const st = state[b];
    const newHash = seqHash(newSeq);
    // if sequences identical, keep as is
    if(newHash === st.lastSeqHash) return;
    // if previous index still valid (e.g., lengths match or longer), keep the remaining for current index
    if(Array.isArray(newSeq) && newSeq.length > 0){
      // if previous idx is within newSeq length and remaining less or equal newSeq[idx], keep remaining
      if(st.idx < newSeq.length && st.remaining !== null && st.remaining !== undefined && newSeq[st.idx] !== null){
        // clamp remaining to newSeq[st.idx]
        st.remaining = Math.min(Math.ceil(newSeq[st.idx]), Math.max(0, Math.floor(st.remaining)));
        st.sequence = newSeq.slice();
      } else {
        // reset to first available item
        st.sequence = newSeq.slice();
        st.idx = 0;
        st.remaining = (st.sequence[0] === null || typeof st.sequence[0] === 'undefined') ? null : Math.ceil(st.sequence[0]);
      }
    } else {
      // no sequence
      st.sequence = [];
      st.idx = 0;
      st.remaining = null;
    }
    st.lastSeqHash = newHash;
  }

  // recompute sequences periodically
  function recomputeFromLatest(){
    const blend = window.LATEST_BLEND || null;
    // flows can be from blend.flows or window.flows etc - try to use binder flows first if present
    const flowsCandidates = (Array.isArray(window.__flowsFromBinder) ? window.__flowsFromBinder : null);
    // prefer blend.flows then window.flows then binder candidate
    const flows = Array.isArray(blend && blend.flows) ? blend.flows : (Array.isArray(window.flows) ? window.flows : flowsCandidates);
    const newSeqs = buildSequencesFromBlend(blend || {}, flows || []);
    for(let b=0;b<BUNKER_COUNT;b++){
      reconcileStateWithNewSeq(b, newSeqs[b] || []);
    }
    updateNextBlendUI();
  }

  // 1s tick to decrease remaining for each bunker
  let _tickTimer = null;
  function tick(){
    for(let b=0;b<BUNKER_COUNT;b++){
      const st = state[b];
      if(!st.sequence || st.sequence.length === 0) { st.remaining = null; continue; }
      // if current sequence item is unavailable (null) then mark remaining null
      if(st.sequence[st.idx] === null){
        st.remaining = null;
        continue;
      }
      if(typeof st.remaining !== 'number' || st.remaining <= 0){
        // start / move to next
        if(st.idx < st.sequence.length){
          // set remaining to ceil of sequence entry (if it's a number)
          if(st.sequence[st.idx] === null || typeof st.sequence[st.idx] === 'undefined'){
            st.remaining = null;
          } else {
            st.remaining = Math.max(0, Math.ceil(st.sequence[st.idx]));
          }
        } else {
          st.remaining = 0;
        }
      } else {
        // decrement
        st.remaining = Math.max(0, st.remaining - 1);
        // if reached zero exactly, step to next item on next tick
        if(st.remaining === 0){
          st.idx++;
          if(st.idx < st.sequence.length && st.sequence[st.idx] !== null){
            st.remaining = Math.max(0, Math.ceil(st.sequence[st.idx]));
          } else {
            // either sequence finished or next item unavailable
            if(st.idx >= st.sequence.length) {
              st.remaining = 0;
            } else {
              st.remaining = null;
            }
          }
        }
      }
    }
    updateNextBlendUI();
  }

  // external helper: allow other code to push flows to binder (coal flow binder emits event flows:update)
  function handleFlowsUpdate(ev){
    try{
      const f = ev && ev.detail && ev.detail.flows;
      if(Array.isArray(f)){
        // store a copy so recompute can pick it up
        window.__flowsFromBinder = f.slice(0);
        recomputeFromLatest();
      }
    }catch(e){}
  }

  // auto-listen to flows:update event (coal flow binder uses this)
  window.addEventListener('flows:update', handleFlowsUpdate, false);

  // public controls
  function startNextBlendBinder(){
    if(_tickTimer) return; // already started
    // initial compute
    recomputeFromLatest();
    _tickTimer = setInterval(tick, TICK_MS);
    // recompute sequences at intervals (to pick up new blend data & changed flows)
    window.__nextBlend_recompute_timer = setInterval(recomputeFromLatest, POLL_RECOMPUTE_MS);
    // also run an immediate recompute every time LATEST_BLEND is updated by your code (not strictly necessary)
    // no direct hook available - recompute on interval suffices
  }
  function stopNextBlendBinder(){
    if(_tickTimer) { clearInterval(_tickTimer); _tickTimer = null; }
    if(window.__nextBlend_recompute_timer){ clearInterval(window.__nextBlend_recompute_timer); window.__nextBlend_recompute_timer = null; }
  }

  // Expose for debugging/control
  window.nextBlendBinder = {
    start: startNextBlendBinder,
    stop: stopNextBlendBinder,
    recompute: recomputeFromLatest,
    state
  };

  // auto-start
  document.addEventListener('DOMContentLoaded', () => {
    // small delay so your refreshAndRender may populate window.LATEST_BLEND and flows
    setTimeout(() => { startNextBlendBinder(); }, 800);
  });

})();
</script>
<script>
/* Robust estimatedGenerationBinder with multi-strategy bottom-coal detection + debug table
   MW = (flow_for_bunker) * (gcv_of_bottom_coal) / heatRate
*/
(function(){
  const BUNKER_COUNT = 6;
  const BOX_PREFIX = 'estGenBox-';
  const UPDATE_MS = 1000;

  function extractNumber(v){
    if(v === null || typeof v === 'undefined') return null;
    if(typeof v === 'number') return v;
    if(typeof v === 'string' && v.trim() !== ''){
      const n = Number(String(v).replace(/,/g,''));
      return Number.isFinite(n) ? n : null;
    }
    if(typeof v === 'object'){
      if(v.$numberInt) return Number(v.$numberInt);
      if(v.$numberDouble) return Number(v.$numberDouble);
      if(v.$numberLong) return Number(v.$numberLong);
      if(v.$date) return Number(v.$date);
      try{
        const s = JSON.stringify(v);
        const m = s.match(/-?\d+(\.\d+)?/);
        if(m) {
          const n = Number(m[0]);
          return Number.isFinite(n) ? n : null;
        }
      }catch(e){}
    }
    return null;
  }

  function getFlows(blend){
    if(Array.isArray(blend && blend.flows)) return blend.flows;
    if(Array.isArray(window.flows)) return window.flows;
    if(Array.isArray(window.__flowsFromBinder)) return window.__flowsFromBinder;
    return [];
  }

  // bottom->top list of row indexes that have non-zero percent for a bunker
  function buildRowIndexSeqForBunker(blend, bunkerIndex){
    const seq = [];
    if(!blend || !Array.isArray(blend.rows)) return seq;
    for(let r = blend.rows.length - 1; r >= 0; r--){
      const row = blend.rows[r];
      let p = null;
      if(Array.isArray(row.percentages) && row.percentages.length > bunkerIndex){
        p = extractNumber(row.percentages[bunkerIndex]);
      } else if(typeof row.percent === 'number' && bunkerIndex === 0){
        p = extractNumber(row.percent);
      } else if(row.percent){
        p = extractNumber(row.percent);
      }
      if(p !== null && p !== 0) seq.push(r);
    }
    return seq;
  }

  // try to read HEATRATE from DOM id first, else from blend.heatRate
  function readHeatRate(blend){
    const el = (typeof document !== 'undefined' && document.getElementById) ? document.getElementById('HEATRATE') : null;
    if(el){
      const txt = (el.value !== undefined && el.value !== null) ? el.value : (el.textContent || el.innerText || '');
      const nn = extractNumber(txt);
      if(nn !== null) return nn;
    }
    return extractNumber(blend && blend.heatRate);
  }

  // helper: try to read rowIndex from blend.bunkers[b].layers bottom layer (if present)
  function getRowIndexFromBunkerLayers(blend, bunkerIndex){
    try{
      if(!blend || !Array.isArray(blend.bunkers)) return null;
      const b = blend.bunkers[bunkerIndex];
      if(!b || !Array.isArray(b.layers) || b.layers.length === 0) return null;
      // I assume layers are ordered bottom->top — if wrong, we'll detect it in debug
      const layer = b.layers[0]; // bottom-most layer
      if(layer && (layer.rowIndex !== undefined || layer.rowIndex !== null)) return layer.rowIndex;
      // there might be 'row' or '_id' mapping – attempt common keys
      if(layer && layer.row !== undefined) return layer.row;
    }catch(e){}
    return null;
  }

  // main tick
  function updateOnce(){
    const blend = window.LATEST_BLEND || {};
    const flows = getFlows(blend);
    const heatRate = readHeatRate(blend);

    const debugRows = [];

    for(let b = 0; b < BUNKER_COUNT; b++){
      const box = document.getElementById(BOX_PREFIX + b);
      const valEl = box ? box.querySelector('.value') : null;

      const rawFlow = Array.isArray(flows) ? flows[b] : null;
      const flowVal = extractNumber(rawFlow);

      // strategy 1: map nextBlendBinder.state[b].idx -> rowIndex using same bottom->top sequence
      let chosenRowIndex = null;
      let chosenBy = null;

      const seq = buildRowIndexSeqForBunker(blend, b); // bottom->top row indexes

      if(window.nextBlendBinder && Array.isArray(window.nextBlendBinder.state)){
        const st = window.nextBlendBinder.state[b];
        if(st && Array.isArray(st.sequence)){
          const idx = (typeof st.idx === 'number') ? st.idx : 0;
          if(Array.isArray(seq) && seq.length > 0){
            const safeIdx = Math.min(Math.max(0, idx), seq.length - 1);
            chosenRowIndex = seq[safeIdx];
            chosenBy = 'nextBlendBinder';
          }
        }
      }

      // strategy 2: use blend.bunkers[b].layers bottom-most (if present)
      if(chosenRowIndex === null){
        const rFromLayers = getRowIndexFromBunkerLayers(blend, b);
        if(rFromLayers !== null && rFromLayers !== undefined) {
          chosenRowIndex = rFromLayers;
          chosenBy = 'bunkerLayers';
        }
      }

      // strategy 3: deterministic bottom-most non-zero percent row
      if(chosenRowIndex === null){
        if(Array.isArray(seq) && seq.length > 0){
          chosenRowIndex = seq[0];
          chosenBy = 'bottomScan';
        }
      }

      // get gcv
      const gcv = (chosenRowIndex !== null && Array.isArray(blend.rows) && blend.rows[chosenRowIndex]) ?
                  extractNumber(blend.rows[chosenRowIndex].gcv) : null;

      let computedMw = null;
      if(flowVal !== null && flowVal > 0 && gcv !== null && typeof heatRate === 'number' && heatRate > 0){
        computedMw = (Number(flowVal) * Number(gcv)) / Number(heatRate);
      }

      // update UI
      if(valEl){
        valEl.innerText = (computedMw === null) ? '--' : (Number.isFinite(computedMw) ? computedMw.toFixed(2) : '--');
      }

      debugRows.push({
        bunker: b,
        rawFlow,
        flowVal,
        heatRate,
        seq_rowIndexes: seq,
        chosenBy,
        chosenRowIndex,
        gcv,
        computedMw
      });
    }

    // compact debug table (one-per-second) — inspect in console to see mismatches
    if(console && console.table){
      // show only key fields
      console.log('EstimatedGen — debug');
      console.table(debugRows.map(r => ({
        bunker: r.bunker,
        flowVal: r.flowVal,
        heatRate: r.heatRate,
        seq_rowIndexes: JSON.stringify(r.seq_rowIndexes),
        chosenBy: r.chosenBy,
        chosenRowIndex: r.chosenRowIndex,
        gcv: r.gcv,
        computedMw: (r.computedMw === null ? '--' : Number.isFinite(r.computedMw) ? r.computedMw.toFixed(2) : '--')
      })));
    }
  }

  // lifecycle
  let __timer = null;
  function start(){
    if(__timer) return;
    updateOnce();
    __timer = setInterval(updateOnce, UPDATE_MS);
    window.addEventListener('flows:update', updateOnce);
    window.addEventListener('blend:updated', updateOnce);
  }
  function stop(){
    if(__timer){ clearInterval(__timer); __timer = null; }
    window.removeEventListener('flows:update', updateOnce);
    window.removeEventListener('blend:updated', updateOnce);
  }

  window.estimatedGenerationBinder = { start, stop, update: updateOnce };

  document.addEventListener('DOMContentLoaded', () => setTimeout(start, 600));
})();
</script>


<!--
Live "draining" visual for bunker layers based on NextBlendBinder timers.
- Smoothly reduces the visible height of the active (bottom) layer as its timer counts down.
- Works with your existing bunker SVGs (they must include rects with data-row and data-mill attributes,
  which your renderBunkerIntoSVG already produces).
- Uses nextBlendBinder.state when available (preferred). Falls back to computing per-layer seconds.
- Adds a small CSS transition so the layer looks like it's "going down" smoothly.
Paste this after your NextBlendBinder & dashboard.js (or anywhere after the bunker SVGs exist).
-->
<style>
  /* smooth SVG rect height/y changes */
  svg rect {
    transition: height 1s linear, y 1s linear, opacity 400ms ease;
  }
  /* optional highlight for the active layer */
  svg rect.util-active {
    filter: drop-shadow(0 2px 6px rgba(0,0,0,0.25));
    opacity: 1 !important;
  }
  svg rect.util-inactive {
    opacity: 0.35;
  }
</style>

<!--
Animated bunker drain that strictly follows your existing per-bunker timers (bunkerTimers).
If your page uses the older bunkerTimers (the timer-setInterval approach in your long script) this
visualizer will *use it* and animate continuously (sub-second) so a 10s layer drains exactly in 10s.
If bunkerTimers isn't present, it will fall back to window.nextBlendBinder state (with elapsed-time
estimates) and finally to computeLayerSeconds() fallback.

Paste this AFTER your existing scripts (the one that defines bunkerTimers/startOrUpdateBunkerTimer etc.)
-->
<!-- <script>
(function(){
  const BUNKER_COUNT = 6;
  const usableTopY = 10, usableBottomY = 140;
  const usableH = usableBottomY - usableTopY;
  const FRAME_RESYNC_MS = 1000;

  // safe number extractor (mongo wrappers + strings)
  function extractNumber(v){
    if(v === null || typeof v === 'undefined') return null;
    if(typeof v === 'number') return v;
    if(typeof v === 'string' && v.trim() !== '') {
      const n = Number(String(v).replace(/,/g,''));
      return Number.isFinite(n) ? n : null;
    }
    if(typeof v === 'object'){
      if(v.$numberInt) return Number(v.$numberInt);
      if(v.$numberDouble) return Number(v.$numberDouble);
      if(v.$numberLong) return Number(v.$numberLong);
      if(v.$date) return Number(v.$date);
      try{
        const s = JSON.stringify(v);
        const m = s.match(/-?\d+(\.\d+)?/);
        if(m) return Number(m[0]);
      }catch(e){}
    }
    return null;
  }

  // Build bottom->top list of blend.row indexes that have a non-zero percent for this bunker
  function buildRowIndexSeqForBunker(blend, bunkerIndex){
    const seq = [];
    if(!blend || !Array.isArray(blend.rows)) return seq;
    for(let r = blend.rows.length - 1; r >= 0; r--){
      const row = blend.rows[r];
      let p = null;
      if(Array.isArray(row.percentages) && row.percentages.length > bunkerIndex){
        p = extractNumber(row.percentages[bunkerIndex]);
      } else if(typeof row.percent === 'number' && bunkerIndex === 0){
        p = extractNumber(row.percent);
      } else if(row.percent){
        p = extractNumber(row.percent);
      }
      if(p !== null && p > 0) seq.push(r);
    }
    return seq;
  }

  // compute fallback layer seconds from blend (replicates your computeLayerSeconds logic)
  function computeLayerSecondsFromBlend(blend, bunkerIndex){
    const bunkerCapacity = extractNumber(blend && blend.bunkerCapacity) || (parseFloat(document.getElementById('bunkerCapacity')?.value) || 0);
    const flows = Array.isArray(blend && blend.flows) ? blend.flows : (Array.isArray(window.__flowsFromBinder) ? window.__flowsFromBinder : (Array.isArray(window.flows) ? window.flows : []));
    const flow = extractNumber(Array.isArray(flows) ? flows[bunkerIndex] : null) || (parseFloat(document.querySelector(`.flow-input[data-mill="${bunkerIndex}"]`)?.value) || 0);
    const seqRowIndexes = buildRowIndexSeqForBunker(blend, bunkerIndex);
    const seconds = seqRowIndexes.map(r => {
      const row = blend.rows && blend.rows[r] ? blend.rows[r] : null;
      let p = null;
      if(row){
        if(Array.isArray(row.percentages) && row.percentages.length > bunkerIndex) p = extractNumber(row.percentages[bunkerIndex]);
        else if(typeof row.percent === 'number' && bunkerIndex === 0) p = extractNumber(row.percent);
        else if(row.percent) p = extractNumber(row.percent);
      }
      if(!bunkerCapacity || !flow || flow <= 0 || p === null || p <= 0) return 0;
      const hours = (Number(p) / 100.0) * Number(bunkerCapacity) / Number(flow);
      return hours * 3600;
    });
    return seconds;
  }

  // Map rowIndex -> rect element for a bunker (created by updateBunkerColors/renderBunkerIntoSVG)
  function mapRectElementsForBunker(bIndex){
    const rects = Array.from(document.querySelectorAll(`svg rect[data-mill="${bIndex}"]`));
    const map = new Map();
    rects.forEach(r => {
      const ra = r.getAttribute('data-row');
      if(ra === null || ra === '') return;
      const ri = isNaN(Number(ra)) ? ra : Number(ra);
      // preserve original full height if present
      if(!r.hasAttribute('data-fullheight')){
        const h = parseFloat(r.getAttribute('height')) || 0;
        r.setAttribute('data-fullheight', String(h));
      }
      map.set(Number(ri), r);
    });
    // fallback: if map empty but rects exist, map by order as best-effort
    if(map.size === 0 && rects.length > 0){
      rects.forEach((r, i) => map.set(i, r));
    }
    return map;
  }

  // Local cache used to compute continuous remaining from integer-second timers
  const local = Array.from({length: BUNKER_COUNT}, () => ({
    seqRowIndexes: [],    // bottom->top blend rows index list
    seqSeconds: [],       // seconds per layer (from bunkerTimers or binder or computed)
    rectMap: new Map(),   // rowIndex -> rect element
    fullHeights: [],      // px full heights per layer (bottom->top)
    // authoritative reference (from bunkerTimers or nextBlendBinder)
    ref: null,            // { idx, remaining, total } last seen
    refTs: 0,             // timestamp ms when ref was recorded
    // current display index (which layer is actively draining)
    displayIdx: 0
  }));

  // sync structural metadata (rect mapping + sequence rows + heights)
  function resyncMetadata(){
    const blend = window.LATEST_BLEND || {};
    for(let b=0;b<BUNKER_COUNT;b++){
      const seq = buildRowIndexSeqForBunker(blend, b);
      local[b].seqRowIndexes = seq.slice();
      local[b].rectMap = mapRectElementsForBunker(b);
      local[b].fullHeights = seq.map(r => {
        const row = blend.rows && blend.rows[r] ? blend.rows[r] : null;
        let p = null;
        if(row){
          if(Array.isArray(row.percentages) && row.percentages.length > b) p = extractNumber(row.percentages[b]);
          else if(typeof row.percent === 'number' && b === 0) p = extractNumber(row.percent);
          else if(row.percent) p = extractNumber(row.percent);
        }
        return p ? (Math.max(0, Math.min(100, Number(p))) / 100) * usableH : 0;
      });
      // ensure displayIdx bounded
      local[b].displayIdx = Math.max(0, Math.min(local[b].displayIdx || 0, Math.max(0, local[b].seqSeconds.length - 1)));
    }
  }

  // Prefer authoritative timers:
  // 1) if your legacy bunkerTimers[] exists and has layersSeconds + layerRemaining -> use it
  // 2) else if window.nextBlendBinder.state present -> use it
  // 3) else fallback to computeLayerSecondsFromBlend()
  function refreshRefsFromSources(){
    const blend = window.LATEST_BLEND || {};
    for(let b=0;b<BUNKER_COUNT;b++){
      // 1) legacy bunkerTimers
      if(Array.isArray(window.bunkerTimers) || (window.bunkerTimers && typeof window.bunkerTimers === 'object')){
        const t = window.bunkerTimers && window.bunkerTimers[b];
        if(t && Array.isArray(t.layersSeconds) && t.layersSeconds.length){
          // make a defensive copy of seconds
          local[b].seqSeconds = t.layersSeconds.map(s => Number(s) || 0);
          // record authoritative ref (remaining/total/idx)
          local[b].ref = {
            idx: Number(t.currentLayer || 0),
            remaining: Number(t.layerRemaining || 0),
            total: Number(t.layersSeconds[t.currentLayer] || 0)
          };
          local[b].refTs = Date.now();
          local[b].displayIdx = local[b].ref.idx;
          continue;
        }
      }

      // 2) nextBlendBinder
      try {
        const ns = window.nextBlendBinder && Array.isArray(window.nextBlendBinder.state) ? window.nextBlendBinder.state[b] : null;
        if(ns && Array.isArray(ns.sequence) && ns.sequence.length){
          local[b].seqSeconds = ns.sequence.map(s => Number(s) || 0);
          local[b].ref = {
            idx: Number(ns.idx || 0),
            remaining: Number(ns.remaining || (ns.sequence[ns.idx] || 0)),
            total: Number(ns.sequence[ns.idx] || 0)
          };
          local[b].refTs = Date.now();
          local[b].displayIdx = local[b].ref.idx;
          continue;
        }
      } catch(e){ /* ignore */ }

      // 3) fallback compute from blend
      local[b].seqSeconds = computeLayerSecondsFromBlend(blend, b).map(s => Number(s) || 0);
      if(local[b].seqSeconds && local[b].seqSeconds.length){
        local[b].ref = { idx: 0, remaining: local[b].seqSeconds[0], total: local[b].seqSeconds[0] };
        local[b].refTs = Date.now();
        local[b].displayIdx = 0;
      } else {
        local[b].ref = null;
        local[b].refTs = 0;
        local[b].displayIdx = 0;
      }
    }
  }

  // Estimate continuous remaining seconds using last seen ref + elapsed time
  function estimateRemaining(b){
    const ref = local[b].ref;
    if(!ref || typeof ref.remaining !== 'number') return null;
    const elapsed = (Date.now() - local[b].refTs) / 1000.0;
    const est = Math.max(0, ref.remaining - elapsed);
    return est;
  }

  // If estimated remaining reaches zero, advance to next layer locally (so UI reveals next layer smoothly)
  function advanceIfFinished(b, estRemaining){
    let didAdvance = false;
    while(estRemaining !== null && estRemaining <= 0){
      const next = local[b].displayIdx + 1;
      if(!Array.isArray(local[b].seqSeconds) || next >= local[b].seqSeconds.length){
        // finished all layers, keep at last index (or set to length-1)
        local[b].displayIdx = Math.min(local[b].displayIdx, Math.max(0, (local[b].seqSeconds.length - 1)));
        break;
      }
      local[b].displayIdx = next;
      // update ref to new layer total (we don't know binder remaining for next until source updates)
      const newTotal = local[b].seqSeconds[next] || 0;
      local[b].ref = { idx: next, remaining: newTotal, total: newTotal };
      local[b].refTs = Date.now();
      estRemaining = newTotal;
      didAdvance = true;
    }
    return didAdvance;
  }

  // Apply computed visible heights to rect elements for a bunker (bottom->top)
  function applyHeightsToRects(b, visibleHeightsArr){
    // visibleHeightsArr is bottom->top px array
    let cum = 0;
    const seqRowIndexes = local[b].seqRowIndexes || [];
    for(let i = 0; i < seqRowIndexes.length; i++){
      const rowIndex = seqRowIndexes[i];
      const rect = local[b].rectMap ? local[b].rectMap.get(Number(rowIndex)) : null;
      const visibleH = Math.max(0, Number(visibleHeightsArr[i] || 0));
      const y = usableBottomY - (cum + visibleH);
      if(rect){
        rect.setAttribute('height', String(visibleH));
        rect.setAttribute('y', String(y));
        if(i === local[b].displayIdx){
          rect.classList.add('util-active'); rect.classList.remove('util-inactive');
        } else {
          rect.classList.remove('util-active'); rect.classList.add('util-inactive');
        }
      }
      cum += visibleH;
    }

    // hide any rects not in seqRowIndexes
    if(local[b].rectMap){
      local[b].rectMap.forEach((rect, rIndex) => {
        if(seqRowIndexes.indexOf(Number(rIndex)) === -1){
          rect.setAttribute('height', '0');
          rect.setAttribute('y', String(usableBottomY));
          rect.classList.remove('util-active');
          rect.classList.add('util-inactive');
        }
      });
    }
  }

  // Main RAF loop: compute visible heights from authoritative timers and update rects.
  let rafId = null;
  function frame(){
    // Refresh compact refs from sources at start of frame (so we always use latest data)
    refreshRefsFromSources();

    for(let b=0;b<BUNKER_COUNT;b++){
      // ensure seqRowIndexes & rectMap exist (resync if empty)
      if(!Array.isArray(local[b].seqRowIndexes) || !local[b].seqRowIndexes.length || !local[b].rectMap || local[b].rectMap.size===0){
        resyncMetadata();
        // ensure seqSeconds also set
        if(!local[b].seqSeconds || !local[b].seqSeconds.length) refreshRefsFromSources();
      }

      // Estimate remaining and advance if needed
      let estRemaining = estimateRemaining(b);
      if(estRemaining === null && Array.isArray(local[b].seqSeconds) && local[b].seqSeconds.length){
        // fallback: treat as full
        estRemaining = local[b].seqSeconds[local[b].displayIdx] || 0;
        local[b].ref = { idx: local[b].displayIdx, remaining: estRemaining, total: local[b].seqSeconds[local[b].displayIdx] || estRemaining };
        local[b].refTs = Date.now();
      }

      // advance layers locally when finished
      advanceIfFinished(b, estRemaining);

      // Recompute estRemaining after any advancement
      estRemaining = estimateRemaining(b);

      // Build visible heights bottom->top
      const visibleHeights = [];
      const seqSeconds = local[b].seqSeconds || [];
      for(let i=0;i<local[b].seqRowIndexes.length;i++){
        const fullH = local[b].fullHeights && typeof local[b].fullHeights[i] === 'number' ? local[b].fullHeights[i] : (local[b].rectMap && local[b].rectMap.get(local[b].seqRowIndexes[i]) ? Number(local[b].rectMap.get(local[b].seqRowIndexes[i]).getAttribute('data-fullheight') || 0) : 0);
        let vh = fullH;
        if(i < local[b].displayIdx){
          vh = 0;
        } else if(i === local[b].displayIdx){
          const totalForLayer = (Array.isArray(seqSeconds) && seqSeconds.length > i) ? Number(seqSeconds[i]) : (local[b].ref ? Number(local[b].ref.total || 0) : 0);
          if(totalForLayer && totalForLayer > 0 && typeof estRemaining === 'number'){
            const frac = Math.max(0, Math.min(1, estRemaining / totalForLayer));
            vh = fullH * frac;
          } else if(totalForLayer === 0){
            vh = 0;
          } else {
            vh = fullH;
          }
        } else {
          vh = fullH;
        }
        visibleHeights.push(vh);
      }

      applyHeightsToRects(b, visibleHeights);
    }

    rafId = requestAnimationFrame(frame);
  }

  // start/stop & periodic resync
  let resyncTimer = null;
  function start(){
    // initial structural sync
    resyncMetadata();
    refreshRefsFromSources();
    if(rafId == null) rafId = requestAnimationFrame(frame);
    if(resyncTimer == null) resyncTimer = setInterval(() => {
      resyncMetadata();
      refreshRefsFromSources();
    }, FRAME_RESYNC_MS);

    // also listen to events your app uses to update blend/flows
    window.addEventListener('flows:update', () => { resyncMetadata(); refreshRefsFromSources(); });
    window.addEventListener('blend:updated', () => { resyncMetadata(); refreshRefsFromSources(); });
    // If your legacy code dispatches any custom event when bunkerTimers change, also listen to it:
    window.addEventListener('bunkertimers:updated', () => { resyncMetadata(); refreshRefsFromSources(); });
  }

  function stop(){
    if(rafId != null){ cancelAnimationFrame(rafId); rafId = null; }
    if(resyncTimer != null){ clearInterval(resyncTimer); resyncTimer = null; }
    window.removeEventListener('flows:update', () => {});
    window.removeEventListener('blend:updated', () => {});
    window.removeEventListener('bunkertimers:updated', () => {});
  }

  // expose control object
  window.bunkerDrainExactAnimator = { start, stop, resync: resyncMetadata };

  // auto-start (after a short delay to let other scripts wire up timers)
  document.addEventListener('DOMContentLoaded', () => { setTimeout(start, 200); });

})();
</script> -->


<!-- Exact-time bunker drain visualizer
  - Drains each active (bottom) layer exactly in accordance with the timer provided by nextBlendBinder.
  - If nextBlendBinder.state is available we use its authoritative sequence[] (seconds) and remaining/idx values.
  - We compute a continuous estimated remaining time by taking the binder's remaining when we saw it and subtracting real elapsed time.
  - When estimated remaining hits 0 we locally advance to the next layer so the UI reveals the next layer without jumping.
  - Falls back to computing seconds from window.LATEST_BLEND if binder is not present.
  - Assumes renderBunkerIntoSVG produced <rect> elements with data-mill (bunker index) and data-row (blend.rows index) attributes.
  - Paste this after your NextBlendBinder / dashboard.js and before the end of the body.
-->

<!-- <script>
(function(){
  const BUNKER_COUNT = 6;
  const usableTopY = 10, usableBottomY = 140;
  const usableH = usableBottomY - usableTopY;

  // ---- helpers ----
  function extractNumber(v){
    if(v === null || typeof v === 'undefined') return null;
    if(typeof v === 'number') return v;
    if(typeof v === 'string' && v.trim() !== '') {
      const n = Number(String(v).replace(/,/g,''));
      return Number.isFinite(n) ? n : null;
    }
    if(typeof v === 'object'){
      if(v.$numberInt) return Number(v.$numberInt);
      if(v.$numberDouble) return Number(v.$numberDouble);
      if(v.$numberLong) return Number(v.$numberLong);
      if(v.$date) return Number(v.$date);
      try{
        const s = JSON.stringify(v);
        const m = s.match(/-?\d+(\.\d+)?/);
        if(m) return Number(m[0]);
      }catch(e){}
    }
    return null;
  }

  // bottom->top list of global blend.rows indices which have a non-zero percent for this bunker
  function buildRowIndexSeqForBunker(blend, bunkerIndex){
    const seq = [];
    if(!blend || !Array.isArray(blend.rows)) return seq;
    for(let r = blend.rows.length - 1; r >= 0; r--){
      const row = blend.rows[r];
      let p = null;
      if(Array.isArray(row.percentages) && row.percentages.length > bunkerIndex){
        p = extractNumber(row.percentages[bunkerIndex]);
      } else if(typeof row.percent === 'number' && bunkerIndex === 0){
        p = extractNumber(row.percent);
      } else if(row.percent){
        p = extractNumber(row.percent);
      }
      if(p !== null && p > 0) seq.push(r);
    }
    return seq;
  }

  // seconds per layer (bottom->top) computed from blend as fallback
  function computeLayerSecondsFromBlend(blend, bunkerIndex){
    const bunkerCapacity = extractNumber(blend && blend.bunkerCapacity) || 0;
    const flows = Array.isArray(blend && blend.flows) ? blend.flows : (Array.isArray(window.__flowsFromBinder) ? window.__flowsFromBinder : []);
    const flow = extractNumber(flows[bunkerIndex]) || 0;
    const seqRowIndexes = buildRowIndexSeqForBunker(blend, bunkerIndex);
    const seconds = seqRowIndexes.map(r => {
      const row = blend.rows && blend.rows[r] ? blend.rows[r] : null;
      let p = null;
      if(row){
        if(Array.isArray(row.percentages) && row.percentages.length > bunkerIndex) p = extractNumber(row.percentages[bunkerIndex]);
        else if(typeof row.percent === 'number' && bunkerIndex === 0) p = extractNumber(row.percent);
        else if(row.percent) p = extractNumber(row.percent);
      }
      if(!bunkerCapacity || !flow || flow <= 0 || p === null || p <= 0) return 0;
      const hours = (Number(p) / 100.0) * Number(bunkerCapacity) / Number(flow);
      return hours * 3600;
    });
    return seconds;
  }

  // map rowIndex -> rect element for a bunker
  function mapRectElementsForBunker(bIndex){
    const rects = Array.from(document.querySelectorAll(`svg rect[data-mill="${bIndex}"]`));
    const map = new Map();

    // Try mapping by explicit data-row attribute first
    rects.forEach(r => {
      const ra = r.getAttribute('data-row');
      if(ra === null || ra === '') return;
      const ri = isNaN(Number(ra)) ? ra : Number(ra);
      map.set(Number(ri), r);
    });

    // fallback: if no mapping found, map by DOM order (best-effort)
    if(map.size === 0 && rects.length > 0){
      // assume rects were appended in bottom->top order by render function
      const seqFallback = rects.slice(0);
      // assign indexes 0..N-1 as temporary keys (these keys won't match blend row indexes)
      seqFallback.forEach((r, idx) => map.set(idx, r));
    }
    return map;
  }

  // compute full heights px for seqRowIndexes (bottom->top) using blend percent
  function computeFullHeights(blend, bunkerIndex, seqRowIndexes){
    return seqRowIndexes.map(r => {
      const row = blend && Array.isArray(blend.rows) ? blend.rows[r] : null;
      let p = null;
      if(row){
        if(Array.isArray(row.percentages) && row.percentages.length > bunkerIndex) p = extractNumber(row.percentages[bunkerIndex]);
        else if(typeof row.percent === 'number' && bunkerIndex === 0) p = extractNumber(row.percent);
        else if(row.percent) p = extractNumber(row.percent);
      }
      return p ? (Math.max(0, Math.min(100, Number(p))) / 100) * usableH : 0;
    });
  }

  function readBinderForBunker(b){
    try{
      const st = window.nextBlendBinder && Array.isArray(window.nextBlendBinder.state) ? window.nextBlendBinder.state[b] : null;
      if(!st) return null;
      return {
        sequence: Array.isArray(st.sequence) ? st.sequence.slice(0) : null,
        idx: (typeof st.idx === 'number') ? st.idx : 0,
        remaining: (typeof st.remaining === 'number') ? st.remaining : null
      };
    }catch(e){ return null; }
  }

  // ---- local state ----
  // binderRef: when we read binder.remaining we store it + timestamp so we can subtract real elapsed time
  const local = Array.from({length: BUNKER_COUNT}, () => ({
    seqRowIndexes: [],   // bottom->top global row indexes
    seqSeconds: [],      // seconds per layer bottom->top
    currentIdx: 0,       // current active layer index used for display
    binderRef: null,     // { remaining, total, idx } at the time we last saw binder
    binderRefTs: 0,      // timestamp ms when binderRef was recorded
    rectMap: new Map(),  // mapping rowIndex -> rect element
    fullHeights: [],     // full heights px bottom->top
  }));

  // Synchronize metadata from blend & binder (called periodically and at start)
  function resyncAll(){
    const blend = window.LATEST_BLEND || {};
    for(let b=0;b<BUNKER_COUNT;b++){
      // row index sequence bottom->top
      const seqRowIndexes = buildRowIndexSeqForBunker(blend, b);
      local[b].seqRowIndexes = seqRowIndexes.slice();

      // rect map
      local[b].rectMap = mapRectElementsForBunker(b);

      // full heights px
      local[b].fullHeights = computeFullHeights(blend, b, seqRowIndexes);

      // prefer binder sequence if available and lengths match
      const binder = readBinderForBunker(b);
      if(binder && Array.isArray(binder.sequence) && binder.sequence.length === seqRowIndexes.length){
        local[b].seqSeconds = binder.sequence.slice();
        local[b].currentIdx = binder.idx || 0;
        local[b].binderRef = {
          remaining: binder.remaining,
          total: binder.sequence[binder.idx] || null,
          idx: binder.idx || 0
        };
        local[b].binderRefTs = Date.now();
      } else {
        // fallback compute seconds from blend
        const secs = computeLayerSecondsFromBlend(blend, b);
        local[b].seqSeconds = secs.slice();
        local[b].currentIdx = 0;
        local[b].binderRef = (secs && secs.length) ? { remaining: secs[0], total: secs[0], idx: 0 } : null;
        local[b].binderRefTs = Date.now();
      }
    }
  }

  // Update when we detect binder changed — update binderRef so elapsed calc stays accurate
  function refreshBinderRefsIfChanged(){
    for(let b=0;b<BUNKER_COUNT;b++){
      const binder = readBinderForBunker(b);
      if(!binder) continue;
      // if sequence changed, replace seqSeconds & recalc mapping (we'll resync seqRowIndexes length)
      if(Array.isArray(binder.sequence) && JSON.stringify(binder.sequence) !== JSON.stringify(local[b].seqSeconds)){
        local[b].seqSeconds = binder.sequence.slice();
        // try to keep seqRowIndexes length match - resync structure
        resyncAll();
      }
      // If idx or remaining changed, update binderRef and timestamp (authoritative)
      const curRef = local[b].binderRef;
      const changedIdx = (binder.idx !== (curRef && curRef.idx));
      const changedRem = (typeof binder.remaining === 'number' && (!curRef || binder.remaining !== curRef.remaining));
      if(changedIdx || changedRem){
        const total = (Array.isArray(binder.sequence) && binder.sequence[binder.idx]) ? binder.sequence[binder.idx] : (local[b].seqSeconds[binder.idx] || null);
        local[b].binderRef = { remaining: binder.remaining, total: total, idx: binder.idx };
        local[b].binderRefTs = Date.now();
        local[b].currentIdx = binder.idx || 0;
      }
    }
  }

  // compute estimated remaining for current layer using binderRef and now
  function estimateRemainingFromBinderRef(b){
    const ref = local[b].binderRef;
    if(!ref || typeof ref.remaining !== 'number') return null;
    const elapsed = (Date.now() - local[b].binderRefTs) / 1000.0;
    return Math.max(0, ref.remaining - elapsed);
  }

  // Advance currentIdx locally when estimated remaining reaches zero so UI reveals next layer immediately
  function tryAdvanceIfNeeded(b, estRemaining){
    let changed = false;
    while(estRemaining !== null && estRemaining <= 0){
      const nextIdx = local[b].currentIdx + 1;
      if(!Array.isArray(local[b].seqSeconds) || nextIdx >= local[b].seqSeconds.length) {
        // no more layers -> keep at end
        local[b].currentIdx = Math.min(local[b].currentIdx, (local[b].seqSeconds.length -1));
        break;
      }
      // advance
      local[b].currentIdx = nextIdx;
      // set new binderRef to the new layer duration (we don't know exact remaining from binder until it updates)
      const nextTotal = local[b].seqSeconds[nextIdx] || null;
      local[b].binderRef = { remaining: nextTotal, total: nextTotal, idx: nextIdx };
      local[b].binderRefTs = Date.now();
      estRemaining = nextTotal;
      changed = true;
    }
    return changed;
  }

  // Core frame update: compute visible heights based on exact fraction = estRemaining/total
  function updateFrame(){
    // first, check binder for small changes (authoritative)
    refreshBinderRefsIfChanged();

    for(let b=0;b<BUNKER_COUNT;b++){
      const seqRowIndexes = local[b].seqRowIndexes || [];
      const seqSeconds = local[b].seqSeconds || [];
      // ensure currentIdx bounds
      local[b].currentIdx = Math.min(Math.max(0, local[b].currentIdx || 0), Math.max(0, seqSeconds.length - 1));

      // estimate remaining for display
      let estRemaining = estimateRemainingFromBinderRef(b);
      // if binderRef missing, fallback to seqSeconds[currentIdx]
      if(estRemaining === null && Array.isArray(seqSeconds) && seqSeconds.length > local[b].currentIdx){
        estRemaining = seqSeconds[local[b].currentIdx];
        // set binderRef so further frames will estimate by elapsed
        local[b].binderRef = { remaining: estRemaining, total: seqSeconds[local[b].currentIdx], idx: local[b].currentIdx };
        local[b].binderRefTs = Date.now();
      }

      // if remaining went to zero, locally advance
      tryAdvanceIfNeeded(b, estRemaining);

      // recompute estRemaining after possible advance
      estRemaining = estimateRemainingFromBinderRef(b);

      // compute fractions & update rects
      let cumVisible = 0;
      for(let layerIdx=0; layerIdx < seqRowIndexes.length; layerIdx++){
        const rowIndex = seqRowIndexes[layerIdx];
        const rect = local[b].rectMap ? local[b].rectMap.get(Number(rowIndex)) : null;
        // determine full height for this layer
        const fullH = (local[b].fullHeights && local[b].fullHeights[layerIdx]) ? Number(local[b].fullHeights[layerIdx]) : 0;
        let visibleH = fullH;

        if(layerIdx < local[b].currentIdx){
          visibleH = 0;
        } else if(layerIdx === local[b].currentIdx){
          const totalForLayer = (Array.isArray(local[b].seqSeconds) && local[b].seqSeconds.length > layerIdx) ? Number(local[b].seqSeconds[layerIdx]) : null;
          if(totalForLayer && totalForLayer > 0 && typeof estRemaining === 'number' && estRemaining >= 0){
            const frac = Math.max(0, Math.min(1, estRemaining / totalForLayer));
            visibleH = fullH * frac;
          } else if(totalForLayer === 0){
            visibleH = 0;
          } else {
            visibleH = fullH;
          }
        } else {
          visibleH = fullH;
        }

        if(rect){
          const y = usableBottomY - (cumVisible + visibleH);
          rect.setAttribute('height', String(visibleH));
          rect.setAttribute('y', String(y));
          if(layerIdx === local[b].currentIdx){
            rect.classList.add('util-active');
            rect.classList.remove('util-inactive');
          } else {
            rect.classList.remove('util-active');
            rect.classList.add('util-inactive');
          }
        }
        cumVisible += visibleH;
      }

      // hide any rects not present in seqRowIndexes
      if(local[b].rectMap){
        local[b].rectMap.forEach((rect, rIndex) => {
          if(seqRowIndexes.indexOf(Number(rIndex)) === -1){
            rect.setAttribute('height', '0');
            rect.setAttribute('y', String(usableBottomY));
            rect.classList.remove('util-active');
            rect.classList.add('util-inactive');
          }
        });
      }
    }

    // schedule next frame
    requestAnimationFrame(updateFrame);
  }

  // ---- start/stop ----
  let started = false;
  let resyncInterval = null;
  function startVisualizer(){
    if(started) return;
    // initial sync
    resyncAll();
    // start RAF loop
    requestAnimationFrame(updateFrame);
    // keep structure in sync every 1s (adjust if you want)
    resyncInterval = setInterval(resyncAll, 1000);
    // also resync when app updates blend/flows
    window.addEventListener('flows:update', resyncAll);
    window.addEventListener('blend:updated', resyncAll);
    started = true;
  }
  function stopVisualizer(){
    if(!started) return;
    if(resyncInterval) { clearInterval(resyncInterval); resyncInterval = null; }
    window.removeEventListener('flows:update', resyncAll);
    window.removeEventListener('blend:updated', resyncAll);
    started = false;
    // note: RAF will continue until page reload; to fully stop you'd need to cancelRequestAnimationFrame (not kept here)
  }

  window.bunkerDrainExact = { start: startVisualizer, stop: stopVisualizer, resync: resyncAll };

  // auto-start shortly after DOM ready so SVGs exist
  document.addEventListener('DOMContentLoaded', () => { setTimeout(startVisualizer, 300); });

})();
</script> -->


<!-- <script>
/*
  Utilization color binder
  - Uses the same bottom->top row-index sequence logic as NextBlendBinder
  - Maps nextBlendBinder.state[b].idx -> actual rowIndex and highlights that rect in bunker SVG
  - Fallbacks: uses bunker.layers rowIndex if available, else bottom-most row from blend.rows
  - Keeps running every 1s and also runs after overview/single render.
*/
(function(){
  const BUNKER_COUNT = 6;
  const POLL_MS = 1000;

  function extractNumber(v){
    if(v === null || typeof v === 'undefined') return null;
    if(typeof v === 'number') return v;
    if(typeof v === 'string' && v.trim() !== ''){
      const n = Number(String(v).replace(/,/g,''));
      return Number.isFinite(n) ? n : null;
    }
    if(typeof v === 'object'){
      if(v.$numberInt) return Number(v.$numberInt);
      if(v.$numberDouble) return Number(v.$numberDouble);
      if(v.$numberLong) return Number(v.$numberLong);
      if(v.$date) return Number(v.$date);
      try{
        const s = JSON.stringify(v);
        const m = s.match(/-?\d+(\.\d+)?/);
        if(m) return Number(m[0]);
      }catch(e){}
    }
    return null;
  }

  // Build bottom->top row index list for a bunker from blend.rows (same logic as binder)
  function buildRowIndexSeqForBunker(blend, bunkerIndex){
    const seq = [];
    if(!blend || !Array.isArray(blend.rows)) return seq;
    for(let r = blend.rows.length - 1; r >= 0; r--){
      const row = blend.rows[r];
      let p = null;
      if(Array.isArray(row.percentages) && row.percentages.length > bunkerIndex){
        p = extractNumber(row.percentages[bunkerIndex]);
      } else if(typeof row.percent === 'number' && bunkerIndex === 0){
        p = extractNumber(row.percent);
      } else if(row.percent){
        p = extractNumber(row.percent);
      }
      if(p !== null && p !== 0) seq.push(r);
    }
    return seq; // e.g. [3, 1] -> bottom rowIndex 3, then 1 above it
  }

  // Try to obtain bottom-most rowIndex from per-bunker layers if present (blend.bunkers[b].layers[0].rowIndex)
  function getRowIndexFromBunkerLayers(blend, bunkerIndex){
    try{
      if(!blend || !Array.isArray(blend.bunkers)) return null;
      const b = blend.bunkers[bunkerIndex];
      if(!b || !Array.isArray(b.layers) || b.layers.length === 0) return null;
      const layer = b.layers[0]; // assumed bottom-most layer in layers[]
      if(layer && (layer.rowIndex !== undefined && layer.rowIndex !== null)) return layer.rowIndex;
    }catch(e){}
    return null;
  }

  // Determine actual chosen rowIndex (the one being utilised) for a bunker
  function determineActiveRowIndex(blend, bunkerIndex){
    const seq = buildRowIndexSeqForBunker(blend, bunkerIndex); // bottom->top row indexes
    // 1) Prefer nextBlendBinder.state mapping
    if(window.nextBlendBinder && Array.isArray(window.nextBlendBinder.state)){
      const st = window.nextBlendBinder.state[bunkerIndex];
      if(st && Array.isArray(st.sequence)){
        const idx = (typeof st.idx === 'number') ? st.idx : 0;
        if(Array.isArray(seq) && seq.length > 0){
          const safeIdx = Math.min(Math.max(0, idx), seq.length - 1);
          return seq[safeIdx];
        }
      }
    }
    // 2) fallback: use per-bunker layer mapping if available
    const rFromLayers = getRowIndexFromBunkerLayers(blend, bunkerIndex);
    if(rFromLayers !== null && rFromLayers !== undefined) return rFromLayers;
    // 3) deterministic fallback: bottom-most row from blend.rows
    if(Array.isArray(seq) && seq.length > 0) return seq[0];
    return null;
  }

  // Update SVG rect classes to reflect utilization
  function updateUtilizationColors(){
    const blend = window.LATEST_BLEND || {};
    for(let b = 0; b < BUNKER_COUNT; b++){
      const activeRowIndex = determineActiveRowIndex(blend, b);
      // select rects inside all SVGs that belong to this bunker (data-mill attribute)
      const rects = document.querySelectorAll(`svg rect[data-mill="${b}"]`);
      rects.forEach(rect => {
        // rect.dataset.row may be string or empty; convert both sides to string for safe compare
        const rectRowAttr = rect.getAttribute('data-row');
        // Some renderers may store rowIndex as number or as string; handle both
        const rectRowNum = (rectRowAttr === null || rectRowAttr === '') ? null : (isNaN(Number(rectRowAttr)) ? rectRowAttr : Number(rectRowAttr));
        if(activeRowIndex === null){
          rect.classList.remove('util-active');
          rect.classList.add('util-inactive');
        } else {
          // If rectRowNum equals activeRowIndex -> active
          if(rectRowNum !== null && Number(rectRowNum) === Number(activeRowIndex)){
            rect.classList.add('util-active');
            rect.classList.remove('util-inactive');
            // also ensure parent bunker element has marker class (optional)
            const bunkerEl = rect.closest('.bunker');
            if(bunkerEl) bunkerEl.classList.add('bunker-util');
          } else {
            rect.classList.remove('util-active');
            rect.classList.add('util-inactive');
          }
        }
      });
    }
  }

  // run periodically and also expose function to call after render
  let __timer = null;
  function start(){
    if(__timer) return;
    updateUtilizationColors();
    __timer = setInterval(updateUtilizationColors, POLL_MS);
    // update on events that change flows/blend/timers
    window.addEventListener('flows:update', updateUtilizationColors);
    window.addEventListener('blend:updated', updateUtilizationColors);
    // keep sync when NextBlendBinder recomputes (it doesn't emit an event by default) - hook into its recompute timer if present:
    if(window.nextBlendBinder && typeof window.nextBlendBinder.recompute === 'function'){
      // nothing to attach to, but we still poll above
    }
  }
  function stop(){
    if(__timer){ clearInterval(__timer); __timer = null; }
    window.removeEventListener('flows:update', updateUtilizationColors);
    window.removeEventListener('blend:updated', updateUtilizationColors);
  }

  // convenience: call update immediately after overview/single render
  // Patch renderOverview and renderSingle by wrapping original functions if present
  function patchRenderHooks(){
    try{
      if(typeof renderOverview === 'function'){
        const orig = renderOverview;
        window.renderOverview = function(blend, coalDB){
          orig.call(this, blend, coalDB);
          // small delay so svg DOM is ready
          setTimeout(updateUtilizationColors, 80);
        };
      }
      if(typeof renderSingle === 'function'){
        const origS = renderSingle;
        window.renderSingle = function(bunkerIndex, blend, coalDB){
          origS.call(this, bunkerIndex, blend, coalDB);
          setTimeout(updateUtilizationColors, 80);
        };
      }
    }catch(e){ /* ignore */ }
  }

  // expose API
  window.utilizationColorBinder = {
    start,
    stop,
    update: updateUtilizationColors,
    determineActiveRowIndex
  };

  document.addEventListener('DOMContentLoaded', () => {
    patchRenderHooks();
    setTimeout(start, 400);
  });
})();
</script> -->








<!-- Estimated Generation (MW) — precise mapping to NextBlendBinder's bottom-coal logic -->
<!-- <script>
(function(){
  const BUNKER_COUNT = 6;
  const BOX_PREFIX = 'estGenBox-';
  const UPDATE_MS = 1000;

  // robust numeric extractor (handles raw numbers, strings and MongoDB wrappers)
  function extractNumber(v){
    if(v === null || typeof v === 'undefined') return null;
    if(typeof v === 'number') return v;
    if(typeof v === 'string' && v.trim() !== ''){
      const n = Number(v.replace(/,/g,'')); // tolerate commas
      return Number.isFinite(n) ? n : null;
    }
    if(typeof v === 'object'){
      if(v.$numberInt) return Number(v.$numberInt);
      if(v.$numberDouble) return Number(v.$numberDouble);
      if(v.$numberLong) return Number(v.$numberLong);
      if(v.$date) return Number(v.$date);
      // fallback: try any numeric-looking substring
      try{
        const s = JSON.stringify(v);
        const m = s.match(/-?\d+(\.\d+)?/);
        if(m) {
          const n = Number(m[0]);
          return Number.isFinite(n) ? n : null;
        }
      }catch(e){}
    }
    return null;
  }

  // flows precedence (same approach as other binders)
  function getFlows(blend){
    if(Array.isArray(blend && blend.flows)) return blend.flows;
    if(Array.isArray(window.flows)) return window.flows;
    if(Array.isArray(window.__flowsFromBinder)) return window.__flowsFromBinder;
    return [];
  }

  // Build per-bunker sequence of row indices in the exact same order NextBlendBinder uses:
  // iterate blend.rows bottom->top and collect rows where percent for that bunker > 0.
  // result: [[rIndex1, rIndex2, ...], ...] for each bunker
  function buildRowIndexSequences(blend){
    const seqs = Array.from({length: BUNKER_COUNT}, () => []);
    if(!blend || !Array.isArray(blend.rows)) return seqs;
    for(let b = 0; b < BUNKER_COUNT; b++){
      for(let r = blend.rows.length - 1; r >= 0; r--){
        const row = blend.rows[r];
        let p = null;
        if(Array.isArray(row.percentages) && row.percentages.length > b){
          p = extractNumber(row.percentages[b]);
        } else if(typeof row.percent === 'number' && b === 0){
          p = extractNumber(row.percent);
        } else if(row.percent){
          p = extractNumber(row.percent);
        }
        if(p !== null && p !== 0){
          seqs[b].push(r); // store actual row index (bottom->top)
        }
      }
    }
    return seqs;
  }

  // read heatRate from DOM element with id "HEATRATE" if present, otherwise fallback to blend.heatRate
  function readHeatRate(blend){
    const el = document.getElementById && document.getElementById('HEATRATE');
    if(el){
      // try element textContent or value
      const txt = (el.value !== undefined && el.value !== null) ? el.value : (el.textContent || el.innerText || '');
      const n = extractNumber(txt);
      if(n !== null) return n;
    }
    return extractNumber(blend && blend.heatRate);
  }

  // single update tick: compute MW per bunker using:
  // MW = (flow_bunker) * (gcv_of_current_bottom_coal_for_bunker) / heatRate
  function updateOnce(){
    const blend = window.LATEST_BLEND || {};
    const flows = getFlows(blend);
    const heatRate = readHeatRate(blend); // prefer DOM HEATRATE id as requested

    // build deterministic rowIndex sequences (bottom->top) matching NextBlendBinder
    const rowIndexSeqs = buildRowIndexSequences(blend);

    for(let b = 0; b < BUNKER_COUNT; b++){
      const box = document.getElementById(BOX_PREFIX + b);
      if(!box) continue;
      const valEl = box.querySelector && box.querySelector('.value');
      if(!valEl) continue;

      const rawFlow = Array.isArray(flows) ? flows[b] : null;
      const flowVal = extractNumber(rawFlow);

      // determine which row index is the "current bottom coal" for this bunker.
      // Prefer nextBlendBinder.state mapping for exact sync with timers; else fallback to first (bottom-most).
      let chosenRowIndex = null;

      if(window.nextBlendBinder && Array.isArray(window.nextBlendBinder.state)){
        try{
          const st = window.nextBlendBinder.state[b];
          if(st && Array.isArray(st.sequence)){
            const idx = (typeof st.idx === 'number') ? st.idx : 0;
            const seq = rowIndexSeqs[b] || [];
            if(seq.length > 0){
              // if idx within bounds use it, otherwise clamp to nearest valid index
              const safeIndex = Math.min(Math.max(0, idx), seq.length - 1);
              chosenRowIndex = seq[safeIndex];
            }
          }
        }catch(e){
          chosenRowIndex = null;
        }
      }

      // fallback deterministic: bottom-most non-zero percent row
      if(chosenRowIndex === null){
        const seq = rowIndexSeqs[b];
        if(Array.isArray(seq) && seq.length > 0) chosenRowIndex = seq[0];
      }

      // read gcv from the chosen row
      const gcv = (chosenRowIndex !== null && Array.isArray(blend.rows) && blend.rows[chosenRowIndex]) ?
                  extractNumber(blend.rows[chosenRowIndex].gcv) : null;

      // compute MW
      let outText = '--';
      if(flowVal !== null && flowVal > 0 && gcv !== null && typeof heatRate === 'number' && heatRate > 0){
        const mw = (Number(flowVal) * Number(gcv)) / Number(heatRate);
        outText = Number.isFinite(mw) ? mw.toFixed(2) : '--';
      }

      valEl.innerText = outText;
    }
  }

  // init / lifecycle
  let __timer = null;
  function start(){
    if(__timer) return;
    updateOnce();
    __timer = setInterval(updateOnce, UPDATE_MS);
    window.addEventListener('flows:update', updateOnce);
    // if your app triggers a custom event after LATEST_BLEND updates, you can call:
    // window.dispatchEvent(new Event('blend:updated')); to force immediate recompute
    window.addEventListener('blend:updated', updateOnce);
  }
  function stop(){
    if(__timer){ clearInterval(__timer); __timer = null; }
    window.removeEventListener('flows:update', updateOnce);
    window.removeEventListener('blend:updated', updateOnce);
  }

  window.estimatedGenerationBinder = { start, stop, update: updateOnce };

  document.addEventListener('DOMContentLoaded', () => {
    // small delay so dashboard may populate window.LATEST_BLEND and nextBlendBinder
    setTimeout(start, 600);
  });
})();
</script> -->



</body>
</html>
